<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">//=============================================================================
// rpg_managers.js v1.5.1
//=============================================================================
/*
 * TODO: finish the first pass.
 * TODO: add docs for &quot;structs&quot;--Objects that have a specified structure but
 *       are not classes, like sounds.
 * TODO: figure out what is read-only.
 * TODO: figure out what is private.
 * TODO: figure out what is static.
 */
//-----------------------------------------------------------------------------

<span id='DataManager-method-constructor'><span id='DataManager'>/**
</span></span> * The static class that manages the database and game objects.
 * @class DataManager
 * @static
 * @singleton
 * @constructor should never be called
 */
function DataManager() {
    throw new Error('This is a static class');
}

/*
TODO: make a fake class called &quot;global&quot; or something
      to document bits like these
*/
var $dataActors       = null;
var $dataClasses      = null;
var $dataSkills       = null;
var $dataItems        = null;
var $dataWeapons      = null;
var $dataArmors       = null;
var $dataEnemies      = null;
var $dataTroops       = null;
var $dataStates       = null;
var $dataAnimations   = null;
var $dataTilesets     = null;
var $dataCommonEvents = null;
var $dataSystem       = null;
var $dataMapInfos     = null;
var $dataMap          = null;
var $gameTemp         = null;
var $gameSystem       = null;
var $gameScreen       = null;
var $gameTimer        = null;
var $gameMessage      = null;
var $gameSwitches     = null;
var $gameVariables    = null;
var $gameSelfSwitches = null;
var $gameActors       = null;
var $gameParty        = null;
var $gameTroop        = null;
var $gameMap          = null;
var $gamePlayer       = null;
var $testEvent        = null;

<span id='DataManager-static-property-_globalId'>/**
</span> * @property {String} _globalId
 * @static
 * @private
 */
DataManager._globalId       = 'RPGMV';

<span id='DataManager-static-property-_lastAccessedId'>/**
</span> * @property {Number} _lastAccessedId
 * @static
 * @private
 */
DataManager._lastAccessedId = 1;

<span id='DataManager-static-property-_errorUrl'>/**
</span> * @property {String} _errorUrl
 * @static
 * @private
 */
DataManager._errorUrl       = null;

<span id='DataManager-static-property-_databaseFiles'>/**
</span> * @property {Object[]} _databaseFiles
 * @static
 * @private
 */
DataManager._databaseFiles = [
    { name: '$dataActors',       src: 'Actors.json'       },
    { name: '$dataClasses',      src: 'Classes.json'      },
    { name: '$dataSkills',       src: 'Skills.json'       },
    { name: '$dataItems',        src: 'Items.json'        },
    { name: '$dataWeapons',      src: 'Weapons.json'      },
    { name: '$dataArmors',       src: 'Armors.json'       },
    { name: '$dataEnemies',      src: 'Enemies.json'      },
    { name: '$dataTroops',       src: 'Troops.json'       },
    { name: '$dataStates',       src: 'States.json'       },
    { name: '$dataAnimations',   src: 'Animations.json'   },
    { name: '$dataTilesets',     src: 'Tilesets.json'     },
    { name: '$dataCommonEvents', src: 'CommonEvents.json' },
    { name: '$dataSystem',       src: 'System.json'       },
    { name: '$dataMapInfos',     src: 'MapInfos.json'     }
];

<span id='DataManager-method-loadDatabase'>/**
</span> * @method loadDatabase
 * Load all the files in DataManager._databaseFiles
 * - also loads event test files.
 */
DataManager.loadDatabase = function() {
    var test = this.isBattleTest() || this.isEventTest();
    var prefix = test ? 'Test_' : '';
    for (var i = 0; i &lt; this._databaseFiles.length; i++) {
        var name = this._databaseFiles[i].name;
        var src = this._databaseFiles[i].src;
        this.loadDataFile(name, prefix + src);
    }
    if (this.isEventTest()) {
        this.loadDataFile('$testEvent', prefix + 'Event.json');
    }
};

<span id='DataManager-method-loadDataFile'>/**
</span> * @method loadDataFile
 * @param {String} name the name for loaded data i.e. '$dataActors'
 * @param {String} src the source file ie 'Actors.json'
 * Load a JSON datafile from from disk.
 * - Sends loaded data to DataManager.onLoad().
 * - Sets DataManager._errorUrl on errors.
 */
DataManager.loadDataFile = function(name, src) {
    var xhr = new XMLHttpRequest();
    var url = 'data/' + src;
    xhr.open('GET', url);
    xhr.overrideMimeType('application/json');
    xhr.onload = function() {
        if (xhr.status &lt; 400) {
            window[name] = JSON.parse(xhr.responseText);
            DataManager.onLoad(window[name]);
        }
    };
    xhr.onerror = this._mapLoader || function() {
        DataManager._errorUrl = DataManager._errorUrl || url;
    };
    window[name] = null;
    xhr.send();
};

<span id='DataManager-method-isDatabaseLoaded'>/**
</span> * @method isDatabaseLoaded
 * Checks if window[name] exists for each database entry.
 * @return {Boolean} whether the database has been loaded.
 */
DataManager.isDatabaseLoaded = function() {
    this.checkError();
    for (var i = 0; i &lt; this._databaseFiles.length; i++) {
        if (!window[this._databaseFiles[i].name]) {
            return false;
        }
    }
    return true;
};

<span id='DataManager-method-loadMapData'>/**
</span> * @method loadMapData
 * Loads a map with id `mapId` into `$dataMap`
 * - Creates an empty map if given an id &lt;= 0
 * @param {Number} mapId The numeric ID of the map to load.
 */
DataManager.loadMapData = function(mapId) {
    if (mapId &gt; 0) {
        var filename = 'Map%1.json'.format(mapId.padZero(3));
        this._mapLoader = ResourceHandler.createLoader('data/' + filename, this.loadDataFile.bind(this, '$dataMap', filename));
        this.loadDataFile('$dataMap', filename);
    } else {
        this.makeEmptyMap();
    }
};

<span id='DataManager-method-makeEmptyMap'>/**
</span> * @method makeEmptyMap
 * Creates an empty map by clearing `$dataMap`
 */
DataManager.makeEmptyMap = function() {
    $dataMap = {};
    $dataMap.data = [];
    $dataMap.events = [];
    $dataMap.width = 100;
    $dataMap.height = 100;
    $dataMap.scrollType = 3;
};

<span id='DataManager-method-isMapLoaded'>/**
</span> * true if $dataMap exists and there are no errors.
 * @method isMapLoaded
 * @return {Boolean}
 */
DataManager.isMapLoaded = function() {
    this.checkError();
    return !!$dataMap;
};

<span id='DataManager-method-onLoad'>/**
</span> * @method onLoad
 * 'Finishes' loaded objects.
 * @param {Object} object the object to 'finish'
 */
DataManager.onLoad = function(object) {
    var array;
    if (object === $dataMap) {
        this.extractMetadata(object);
        array = object.events;
    } else {
        array = object;
    }
    if (Array.isArray(array)) {
        for (var i = 0; i &lt; array.length; i++) {
            var data = array[i];
            if (data &amp;&amp; data.note !== undefined) {
                this.extractMetadata(data);
            }
        }
    }
    if (object === $dataSystem) {
        Decrypter.hasEncryptedImages = !!object.hasEncryptedImages;
        Decrypter.hasEncryptedAudio = !!object.hasEncryptedAudio;
        Scene_Boot.loadSystemImages();
    }
};

<span id='DataManager-method-extractMetadata'>/**
</span> * @method extractMetadata
 * Extracts notetags from loaded objects.
 * @param {Object} data the object to extract notetags from
 */
DataManager.extractMetadata = function(data) {
    var re = /&lt;([^&lt;&gt;:]+)(:?)([^&gt;]*)&gt;/g;
    data.meta = {};
    for (;;) {
        var match = re.exec(data.note);
        if (match) {
            if (match[2] === ':') {
                data.meta[match[1]] = match[3];
            } else {
                data.meta[match[1]] = true;
            }
        } else {
            break;
        }
    }
};

<span id='DataManager-method-checkError'>/**
</span> * @method checkError
 * Checks DataManager._errorUrl and throws an error if necessary.
 */
DataManager.checkError = function() {
    if (DataManager._errorUrl) {
        throw new Error('Failed to load: ' + DataManager._errorUrl);
    }
};

<span id='DataManager-method-isBattleTest'>/**
</span> * @method isBattleTest
 * @return {Boolean}
 */
DataManager.isBattleTest = function() {
    return Utils.isOptionValid('btest');
};

<span id='DataManager-method-isEventTest'>/**
</span> * @method isEventTest
 * @return {Boolean}
 */
DataManager.isEventTest = function() {
    return Utils.isOptionValid('etest');
};

<span id='DataManager-method-isSkill'>/**
</span> * @method isSkill
 * @param {Object} item The item to check.
 * @return {Boolean}
 */
DataManager.isSkill = function(item) {
    return item &amp;&amp; $dataSkills.contains(item);
};

<span id='DataManager-method-isItem'>/**
</span> * @method isItem
 * @param {Object} item The item to check.
 * @return {Boolean}
 */
DataManager.isItem = function(item) {
    return item &amp;&amp; $dataItems.contains(item);
};

<span id='DataManager-method-isWeapon'>/**
</span> * @method isWeapon
 * @param {Object} item The item to check.
 * @return {Boolean}
 */
DataManager.isWeapon = function(item) {
    return item &amp;&amp; $dataWeapons.contains(item);
};

<span id='DataManager-method-isArmor'>/**
</span> * @method isArmor
 * @param {Object} item The item to check.
 * @return {Boolean}
 */
DataManager.isArmor = function(item) {
    return item &amp;&amp; $dataArmors.contains(item);
};

<span id='DataManager-method-createGameObjects'>/**
</span> * @method createGameObjects
 * Creates a fresh instance of each game container ($gameTemp, etc).
 */
DataManager.createGameObjects = function() {
    $gameTemp          = new Game_Temp();
    $gameSystem        = new Game_System();
    $gameScreen        = new Game_Screen();
    $gameTimer         = new Game_Timer();
    $gameMessage       = new Game_Message();
    $gameSwitches      = new Game_Switches();
    $gameVariables     = new Game_Variables();
    $gameSelfSwitches  = new Game_SelfSwitches();
    $gameActors        = new Game_Actors();
    $gameParty         = new Game_Party();
    $gameTroop         = new Game_Troop();
    $gameMap           = new Game_Map();
    $gamePlayer        = new Game_Player();
};

<span id='DataManager-method-setupNewGame'>/**
</span> * @method setupNewGame
 * Sets up core game data, sets up a new save file, resets frame count, etc.
 */
DataManager.setupNewGame = function() {
    this.createGameObjects();
    this.selectSavefileForNewGame();
    $gameParty.setupStartingMembers();
    $gamePlayer.reserveTransfer($dataSystem.startMapId,
        $dataSystem.startX, $dataSystem.startY);
    Graphics.frameCount = 0;
};

<span id='DataManager-method-setupBattleTest'>/**
</span> * @method setupBattleTest
 */
DataManager.setupBattleTest = function() {
    this.createGameObjects();
    $gameParty.setupBattleTest();
    BattleManager.setup($dataSystem.testTroopId, true, false);
    BattleManager.setBattleTest(true);
    BattleManager.playBattleBgm();
};

<span id='DataManager-method-setupEventTest'>/**
</span> * @method setupEventTest
 */
DataManager.setupEventTest = function() {
    this.createGameObjects();
    this.selectSavefileForNewGame();
    $gameParty.setupStartingMembers();
    $gamePlayer.reserveTransfer(-1, 8, 6);
    $gamePlayer.setTransparent(false);
};

<span id='DataManager-method-loadGlobalInfo'>/**
</span> * @method loadGlobalInfo
 * @return {Array}
 */
DataManager.loadGlobalInfo = function() {
    var json;
    try {
        json = StorageManager.load(0);
    } catch (e) {
        console.error(e);
        return [];
    }
    if (json) {
        var globalInfo = JSON.parse(json);
        for (var i = 1; i &lt;= this.maxSavefiles(); i++) {
            if (!StorageManager.exists(i)) {
                delete globalInfo[i];
            }
        }
        return globalInfo;
    } else {
        return [];
    }
};

<span id='DataManager-method-saveGlobalInfo'>/**
</span> * @method saveGlobalInfo
 * @param {Object} info the data to be saved
 */
DataManager.saveGlobalInfo = function(info) {
    StorageManager.save(0, JSON.stringify(info));
};

<span id='DataManager-method-isThisGameFile'>/**
</span> * @method isThisGameFile
 * @param {Number} savefileId the save file to check
 * @return {Boolean}
 */
DataManager.isThisGameFile = function(savefileId) {
    var globalInfo = this.loadGlobalInfo();
    if (globalInfo &amp;&amp; globalInfo[savefileId]) {
        if (StorageManager.isLocalMode()) {
            return true;
        } else {
            var savefile = globalInfo[savefileId];
            return (savefile.globalId === this._globalId &amp;&amp;
                    savefile.title === $dataSystem.gameTitle);
        }
    } else {
        return false;
    }
};

<span id='DataManager-method-isAnySavefileExists'>/**
</span> * @method isAnySavefileExists
 * @return {Boolean}
 */
DataManager.isAnySavefileExists = function() {
    var globalInfo = this.loadGlobalInfo();
    if (globalInfo) {
        for (var i = 1; i &lt; globalInfo.length; i++) {
            if (this.isThisGameFile(i)) {
                return true;
            }
        }
    }
    return false;
};

<span id='DataManager-method-latestSavefileId'>/**
</span> * @method latestSavefileId
 * @return {Number}
 */
DataManager.latestSavefileId = function() {
    var globalInfo = this.loadGlobalInfo();
    var savefileId = 1;
    var timestamp = 0;
    if (globalInfo) {
        for (var i = 1; i &lt; globalInfo.length; i++) {
            if (this.isThisGameFile(i) &amp;&amp; globalInfo[i].timestamp &gt; timestamp) {
                timestamp = globalInfo[i].timestamp;
                savefileId = i;
            }
        }
    }
    return savefileId;
};

<span id='DataManager-method-loadAllSavefileImages'>/**
</span> * @method loadAllSavefileImages
 */
DataManager.loadAllSavefileImages = function() {
    var globalInfo = this.loadGlobalInfo();
    if (globalInfo) {
        for (var i = 1; i &lt; globalInfo.length; i++) {
            if (this.isThisGameFile(i)) {
                var info = globalInfo[i];
                this.loadSavefileImages(info);
            }
        }
    }
};

<span id='DataManager-method-loadSavefileImages'>/**
</span> * @method loadSavefileImages
 * Reserves needed images.
 */
DataManager.loadSavefileImages = function(info) {
    if (info.characters) {
        for (var i = 0; i &lt; info.characters.length; i++) {
            ImageManager.reserveCharacter(info.characters[i][0]);
        }
    }
    if (info.faces) {
        for (var j = 0; j &lt; info.faces.length; j++) {
            ImageManager.reserveFace(info.faces[j][0]);
        }
    }
};

<span id='DataManager-method-maxSavefiles'>/**
</span> * @method maxSavefiles
 * Always returns 20.
 * @return {Number}
 */
DataManager.maxSavefiles = function() {
    return 20;
};

<span id='DataManager-method-saveGame'>/**
</span> * @method saveGame
 * @param {Number} savefileId the file to save to.
 * @return {Boolean} true if successful.
 */
DataManager.saveGame = function(savefileId) {
    try {
        StorageManager.backup(savefileId);
        return this.saveGameWithoutRescue(savefileId);
    } catch (e) {
        console.error(e);
        try {
            StorageManager.remove(savefileId);
            StorageManager.restoreBackup(savefileId);
        } catch (e2) {
        }
        return false;
    }
};

<span id='DataManager-method-loadGame'>/**
</span> * @method loadGame
 * @param {Number} savefileId the file to load.
 * @return {Boolean} true if successful.
 */
DataManager.loadGame = function(savefileId) {
    try {
        return this.loadGameWithoutRescue(savefileId);
    } catch (e) {
        console.error(e);
        return false;
    }
};

<span id='DataManager-method-loadSavefileInfo'>/**
</span> * @method loadSavefileInfo
 * @param {Number} savefileId the file to get info for.
 * @return {Array} the info or null if unsuccessful.
 */
DataManager.loadSavefileInfo = function(savefileId) {
    var globalInfo = this.loadGlobalInfo();
    return (globalInfo &amp;&amp; globalInfo[savefileId]) ? globalInfo[savefileId] : null;
};

<span id='DataManager-method-lastAccessedSavefileId'>/**
</span> * @method lastAccessedSavefileId
 * @return {Number}
 */
DataManager.lastAccessedSavefileId = function() {
    return this._lastAccessedId;
};

<span id='DataManager-method-saveGameWithoutRescue'>/**
</span> * @method saveGameWithoutRescue
 * @param {Number} savefileId
 * @return {Boolean}
 */
DataManager.saveGameWithoutRescue = function(savefileId) {
    var json = JsonEx.stringify(this.makeSaveContents());
    if (json.length &gt;= 200000) {
        console.warn('Save data too big!');
    }
    StorageManager.save(savefileId, json);
    this._lastAccessedId = savefileId;
    var globalInfo = this.loadGlobalInfo() || [];
    globalInfo[savefileId] = this.makeSavefileInfo();
    this.saveGlobalInfo(globalInfo);
    return true;
};

<span id='DataManager-method-loadGameWithoutRescue'>/**
</span> * @method loadGameWithoutRescue
 * @param {Number} savefileId
 * @return {Boolean}
 */
DataManager.loadGameWithoutRescue = function(savefileId) {
    var globalInfo = this.loadGlobalInfo();
    if (this.isThisGameFile(savefileId)) {
        var json = StorageManager.load(savefileId);
        this.createGameObjects();
        this.extractSaveContents(JsonEx.parse(json));
        this._lastAccessedId = savefileId;
        return true;
    } else {
        return false;
    }
};

<span id='DataManager-method-selectSavefileForNewGame'>/**
</span> * @method selectSavefileForNewGame
 * @return {Number}
 */
DataManager.selectSavefileForNewGame = function() {
    var globalInfo = this.loadGlobalInfo();
    this._lastAccessedId = 1;
    if (globalInfo) {
        var numSavefiles = Math.max(0, globalInfo.length - 1);
        if (numSavefiles &lt; this.maxSavefiles()) {
            this._lastAccessedId = numSavefiles + 1;
        } else {
            var timestamp = Number.MAX_VALUE;
            for (var i = 1; i &lt; globalInfo.length; i++) {
                if (!globalInfo[i]) {
                    this._lastAccessedId = i;
                    break;
                }
                if (globalInfo[i].timestamp &lt; timestamp) {
                    timestamp = globalInfo[i].timestamp;
                    this._lastAccessedId = i;
                }
            }
        }
    }
};

<span id='DataManager-method-makeSavefileInfo'>/**
</span> * @method makeSavefileInfo
 * @return {Object}
 */
DataManager.makeSavefileInfo = function() {
    var info = {};
    info.globalId   = this._globalId;
    info.title      = $dataSystem.gameTitle;
    info.characters = $gameParty.charactersForSavefile();
    info.faces      = $gameParty.facesForSavefile();
    info.playtime   = $gameSystem.playtimeText();
    info.timestamp  = Date.now();
    return info;
};

<span id='DataManager-method-makeSaveContents'>/**
</span> * @method makeSaveContents
 * Get data from global containers to save ($gameSystem, etc).
 * @return {Object}
 */
DataManager.makeSaveContents = function() {
    // A save data does not contain $gameTemp, $gameMessage, and $gameTroop.
    var contents = {};
    contents.system       = $gameSystem;
    contents.screen       = $gameScreen;
    contents.timer        = $gameTimer;
    contents.switches     = $gameSwitches;
    contents.variables    = $gameVariables;
    contents.selfSwitches = $gameSelfSwitches;
    contents.actors       = $gameActors;
    contents.party        = $gameParty;
    contents.map          = $gameMap;
    contents.player       = $gamePlayer;
    return contents;
};

<span id='DataManager-method-extractSaveContents'>/**
</span> * @method extractSaveContents
 * Take data from loaded save contents and put it in global data containers
 * ($gameSystem, etc)
 * @param {Object} contents the data to extract.
 */
DataManager.extractSaveContents = function(contents) {
    $gameSystem        = contents.system;
    $gameScreen        = contents.screen;
    $gameTimer         = contents.timer;
    $gameSwitches      = contents.switches;
    $gameVariables     = contents.variables;
    $gameSelfSwitches  = contents.selfSwitches;
    $gameActors        = contents.actors;
    $gameParty         = contents.party;
    $gameMap           = contents.map;
    $gamePlayer        = contents.player;
};


//-----------------------------------------------------------------------------
// ConfigManager
//
// The static class that manages the configuration data.

<span id='ConfigManager-method-constructor'><span id='ConfigManager'>/**
</span></span> * The static class that manages the configuration data.
 * @class ConfigManager
 * @singleton
 * @static
 * @uses AudioManager
 * @uses StorageManager
 * @uses JSON
 *
 * @constructor should never be called
 */
function ConfigManager() {
    throw new Error('This is a static class');
}

<span id='ConfigManager-static-property-alwaysDash'>/**
</span> * @property {Boolean} alwaysDash
 * @static
 */
ConfigManager.alwaysDash        = false;

<span id='ConfigManager-static-property-commandRemember'>/**
</span> * @property {Boolean} commandRemember
 * @static
 */
ConfigManager.commandRemember   = false;

<span id='ConfigManager-static-property-bgmVolume'>/**
</span> * @property {Number} bgmVolume the volume of BGM, range [0,100]
 * @static
 */
Object.defineProperty(ConfigManager, 'bgmVolume', {
    get: function() {
        return AudioManager._bgmVolume;
    },
    set: function(value) {
        AudioManager.bgmVolume = value;
    },
    configurable: true
});

<span id='ConfigManager-static-property-bgsVolume'>/**
</span> * @property {Number} bgsVolume the volume of BGS, range [0,100]
 * @static
 */
Object.defineProperty(ConfigManager, 'bgsVolume', {
    get: function() {
        return AudioManager.bgsVolume;
    },
    set: function(value) {
        AudioManager.bgsVolume = value;
    },
    configurable: true
});

<span id='ConfigManager-static-property-meVolume'>/**
</span> * @property {Number} meVolume the volume of ME, range [0,100]
 * @static
 */
Object.defineProperty(ConfigManager, 'meVolume', {
    get: function() {
        return AudioManager.meVolume;
    },
    set: function(value) {
        AudioManager.meVolume = value;
    },
    configurable: true
});

<span id='ConfigManager-static-property-seVolume'>/**
</span> * @property {Number} seVolume the volume of SE, range [0,100]
 * @static
 */
Object.defineProperty(ConfigManager, 'seVolume', {
    get: function() {
        return AudioManager.seVolume;
    },
    set: function(value) {
        AudioManager.seVolume = value;
    },
    configurable: true
});

<span id='ConfigManager-method-load'>/**
</span> * @method load loads the game's config
 */
ConfigManager.load = function() {
    var json;
    var config = {};
    try {
        json = StorageManager.load(-1);
    } catch (e) {
        console.error(e);
    }
    if (json) {
        config = JSON.parse(json);
    }
    this.applyData(config);
};

<span id='ConfigManager-method-save'>/**
</span> * @method save saves the game's config
 */
ConfigManager.save = function() {
    StorageManager.save(-1, JSON.stringify(this.makeData()));
};

<span id='ConfigManager-static-method-makeData'>/**
</span> * @method makeData
 * takes current state to create a `config` object
 * @return {Object} config
 * @static
 */
ConfigManager.makeData = function() {
    var config = {};
    config.alwaysDash = this.alwaysDash;
    config.commandRemember = this.commandRemember;
    config.bgmVolume = this.bgmVolume;
    config.bgsVolume = this.bgsVolume;
    config.meVolume = this.meVolume;
    config.seVolume = this.seVolume;
    return config;
};

<span id='ConfigManager-static-method-applyData'>/**
</span> * @method applyData
 * @static
 * applies a `config` object.
 * see ConfigManager.makeData for structure of `config`
 * @param {Object} config
 */
ConfigManager.applyData = function(config) {
    this.alwaysDash = this.readFlag(config, 'alwaysDash');
    this.commandRemember = this.readFlag(config, 'commandRemember');
    this.bgmVolume = this.readVolume(config, 'bgmVolume');
    this.bgsVolume = this.readVolume(config, 'bgsVolume');
    this.meVolume = this.readVolume(config, 'meVolume');
    this.seVolume = this.readVolume(config, 'seVolume');
};

<span id='ConfigManager-static-method-readFlag'>/**
</span> * @method readFlag
 * Reads a boolean flag from a `config` object.
 * @static
 * @param {Object} config the `config` object to read from
 * @param {String} name the name of the flag
 * @return {Boolean}
 */
ConfigManager.readFlag = function(config, name) {
    return !!config[name];
};

<span id='ConfigManager-static-method-readVolume'>/**
</span> * @method readVolume
 * Reads a volume setting from a `config` object.
 * @static
 * @param {Object} config the `config` object to read from
 * @param {String} name the name of the flag
 * @return {Number} [0, 100]
 */
ConfigManager.readVolume = function(config, name) {
    var value = config[name];
    if (value !== undefined) {
        return Number(value).clamp(0, 100);
    } else {
        return 100;
    }
};

//-----------------------------------------------------------------------------
// StorageManager
//
// The static class that manages storage for saving game data.

<span id='StorageManager-method-constructor'><span id='StorageManager'>/**
</span></span> * The static class that manages storage for saving game data.
 * @class StorageManager
 * @static
 * @singleton
 * @uses LZString
 * @uses fs
 * @uses JSON
 * @uses Utils
 *
 * @constructor should never be used
 */
function StorageManager() {
    throw new Error('This is a static class');
}

<span id='StorageManager-static-method-save'>/**
</span> * @method save
 * Writes a savefile.
 * @static
 * @param {Number} savefileId the index of the savefile
 * @param {String} json the data to save
 */
StorageManager.save = function(savefileId, json) {
    if (this.isLocalMode()) {
        this.saveToLocalFile(savefileId, json);
    } else {
        this.saveToWebStorage(savefileId, json);
    }
};

<span id='StorageManager-static-method-load'>/**
</span> * @method load
 * Loads a savefile. `true` on success
 * @static
 * @param {Number} savefileId the index of the savefile
 * @return {Boolean} true on success
 */
StorageManager.load = function(savefileId) {
    if (this.isLocalMode()) {
        return this.loadFromLocalFile(savefileId);
    } else {
        return this.loadFromWebStorage(savefileId);
    }
};

<span id='StorageManager-static-method-exists'>/**
</span> * @method exists
 * Check if a savefile exists.
 * @static
 * @param {Number} savefileId the index of the savefile
 * @return {Boolean} true on success
 */
StorageManager.exists = function(savefileId) {
    if (this.isLocalMode()) {
        return this.localFileExists(savefileId);
    } else {
        return this.webStorageExists(savefileId);
    }
};

<span id='StorageManager-static-method-remove'>/**
</span> * @method remove
 * Remove a savefile.
 * @static
 * @param {Number} savefileId the index of the savefile
 */
StorageManager.remove = function(savefileId) {
    if (this.isLocalMode()) {
        this.removeLocalFile(savefileId);
    } else {
        this.removeWebStorage(savefileId);
    }
};

<span id='StorageManager-static-method-backup'>/**
</span> * @method backup
 * Backup a save file, in case of corruption.
 * @static
 * @param {Number} savefileId the index of the savefile
 */
StorageManager.backup = function(savefileId) {
    if (this.exists(savefileId)) {
        if (this.isLocalMode()) {
            var data = this.loadFromLocalFile(savefileId);
            var compressed = LZString.compressToBase64(data);
            var fs = require('fs');
            var dirPath = this.localFileDirectoryPath();
            var filePath = this.localFilePath(savefileId) + &quot;.bak&quot;;
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath);
            }
            fs.writeFileSync(filePath, compressed);
        } else {
            var data = this.loadFromWebStorage(savefileId);
            var compressed = LZString.compressToBase64(data);
            var key = this.webStorageKey(savefileId) + &quot;bak&quot;;
            localStorage.setItem(key, compressed);
        }
    }
};

<span id='StorageManager-static-method-backupExists'>/**
</span> * @method backupExists
 * Check if a backup exists for a savefile.
 * @static
 * @param {Number} savefileId the index of the savefile
 * @return {Boolean} true if there's a backup
 */
StorageManager.backupExists = function(savefileId) {
    if (this.isLocalMode()) {
        return this.localFileBackupExists(savefileId);
    } else {
        return this.webStorageBackupExists(savefileId);
    }
};

<span id='StorageManager-static-method-cleanBackup'>/**
</span> * @method cleanBackup
 * Remove a savefile backup.
 * @static
 * @param {Number} savefileId the index of the savefile
 */
StorageManager.cleanBackup = function(savefileId) {
	if (this.backupExists(savefileId)) {
		if (this.isLocalMode()) {
			var fs = require('fs');
            var dirPath = this.localFileDirectoryPath();
            var filePath = this.localFilePath(savefileId);
            fs.unlinkSync(filePath + &quot;.bak&quot;);
		} else {
		    var key = this.webStorageKey(savefileId);
			localStorage.removeItem(key + &quot;bak&quot;);
		}
	}
};

<span id='StorageManager-static-method-restoreBackup'>/**
</span> * @method restoreBackup
 * Restore a savefile from a backup.
 * @static
 * @param {Number} savefileId the index of the savefile
 */
StorageManager.restoreBackup = function(savefileId) {
    if (this.backupExists(savefileId)) {
        if (this.isLocalMode()) {
            var data = this.loadFromLocalBackupFile(savefileId);
            var compressed = LZString.compressToBase64(data);
            var fs = require('fs');
            var dirPath = this.localFileDirectoryPath();
            var filePath = this.localFilePath(savefileId);
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath);
            }
            fs.writeFileSync(filePath, compressed);
            fs.unlinkSync(filePath + &quot;.bak&quot;);
        } else {
            var data = this.loadFromWebStorageBackup(savefileId);
            var compressed = LZString.compressToBase64(data);
            var key = this.webStorageKey(savefileId);
            localStorage.setItem(key, compressed);
            localStorage.removeItem(key + &quot;bak&quot;);
        }
    }
};

<span id='StorageManager-static-method-isLocalMode'>/**
</span> * @method isLocalMode
 * Check if we're running locally or on the web.
 * @static
 * @return {Boolean}
 */
StorageManager.isLocalMode = function() {
    return Utils.isNwjs();
};

<span id='StorageManager-static-method-saveToLocalFile'>/**
</span> * @method saveToLocalFile
 * Write a savefile locally.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @param {String} json the savedata.
 */
StorageManager.saveToLocalFile = function(savefileId, json) {
    var data = LZString.compressToBase64(json);
    var fs = require('fs');
    var dirPath = this.localFileDirectoryPath();
    var filePath = this.localFilePath(savefileId);
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath);
    }
    fs.writeFileSync(filePath, data);
};

<span id='StorageManager-static-method-loadFromLocalFile'>/**
</span> * @method loadFromLocalFile
 * Load a local savefile. Returns decompressed savedata.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {String} decompressed savedata
 */
StorageManager.loadFromLocalFile = function(savefileId) {
    var data = null;
    var fs = require('fs');
    var filePath = this.localFilePath(savefileId);
    if (fs.existsSync(filePath)) {
        data = fs.readFileSync(filePath, { encoding: 'utf8' });
    }
    return LZString.decompressFromBase64(data);
};

<span id='StorageManager-static-method-loadFromLocalBackupFile'>/**
</span> * @method loadFromLocalBackupFile
 * Load a local savefile backup. Returns decompressed savedata.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {String} decompressed savedata
 */
StorageManager.loadFromLocalBackupFile = function(savefileId) {
    var data = null;
    var fs = require('fs');
    var filePath = this.localFilePath(savefileId) + &quot;.bak&quot;;
    if (fs.existsSync(filePath)) {
        data = fs.readFileSync(filePath, { encoding: 'utf8' });
    }
    return LZString.decompressFromBase64(data);
};

<span id='StorageManager-static-method-localFileBackupExists'>/**
</span> * @method localFileBackupExists
 * Check if a local savefile has a backup.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {Boolean}
 */
StorageManager.localFileBackupExists = function(savefileId) {
    var fs = require('fs');
    return fs.existsSync(this.localFilePath(savefileId) + &quot;.bak&quot;);
};

<span id='StorageManager-static-method-localFileExists'>/**
</span> * @method localFileExists
 * Check if a local savefile exists.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {Boolean}
 */
StorageManager.localFileExists = function(savefileId) {
    var fs = require('fs');
    return fs.existsSync(this.localFilePath(savefileId));
};

<span id='StorageManager-static-method-removeLocalFile'>/**
</span> * @method removeLocalFile
 * Remove a local savefile
 * @static
 * @param {Number} savefileId the savefile index to use.
 */
StorageManager.removeLocalFile = function(savefileId) {
    var fs = require('fs');
    var filePath = this.localFilePath(savefileId);
    if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
};

<span id='StorageManager-static-method-saveToWebStorage'>/**
</span> * @method saveToWebStorage
 * Write a savefile to web storage.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @param {String} json savedata
 */
StorageManager.saveToWebStorage = function(savefileId, json) {
    var key = this.webStorageKey(savefileId);
    var data = LZString.compressToBase64(json);
    localStorage.setItem(key, data);
};

<span id='StorageManager-static-method-loadFromWebStorage'>/**
</span> * @method loadFromWebStorage
 * Load a savefile from web storage. Returns decompressed savedata.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {String} decompressed savedata
 */
StorageManager.loadFromWebStorage = function(savefileId) {
    var key = this.webStorageKey(savefileId);
    var data = localStorage.getItem(key);
    return LZString.decompressFromBase64(data);
};

<span id='StorageManager-static-method-loadFromWebStorageBackup'>/**
</span> * @method loadFromWebStorageBackup
 * Load a savefile backup from web storage. Returns decompressed savedata.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {String} decompressed savedata
 */
StorageManager.loadFromWebStorageBackup = function(savefileId) {
    var key = this.webStorageKey(savefileId) + &quot;bak&quot;;
    var data = localStorage.getItem(key);
    return LZString.decompressFromBase64(data);
};

<span id='StorageManager-static-method-webStorageBackupExists'>/**
</span> * @method webStorageBackupExists
 * Check if a web storage backup exists for a savefile.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {Boolean}
 */
StorageManager.webStorageBackupExists = function(savefileId) {
    var key = this.webStorageKey(savefileId) + &quot;bak&quot;;
    return !!localStorage.getItem(key);
};

<span id='StorageManager-static-method-webStorageExists'>/**
</span> * @method webStorageExists
 * Check if a web storage savefile exists.
 * @static
 * @param {Number} savefileId the savefile index to use.
 * @return {Boolean}
 */
StorageManager.webStorageExists = function(savefileId) {
    var key = this.webStorageKey(savefileId);
    return !!localStorage.getItem(key);
};

<span id='StorageManager-static-method-removeWebStorage'>/**
</span> * @method removeWebStorage
 * Remove a savefile in web storage.
 * @static
 * @param {Number} savefileId the savefile index to use.
 */
StorageManager.removeWebStorage = function(savefileId) {
    var key = this.webStorageKey(savefileId);
    localStorage.removeItem(key);
};

<span id='StorageManager-static-method-localFileDirectoryPath'>/**
</span> * @method localFileDirectoryPath
 * Get the savefile path.
 * @static
 * @return {String} the path
 */
StorageManager.localFileDirectoryPath = function() {
    var path = require('path');

    var base = path.dirname(process.mainModule.filename);
    return path.join(base, 'save/');
};

<span id='StorageManager-static-method-localFilePath'>/**
</span> * @method localFilePath
 * Get the savefile path for a specific savefile.
 * @static
 * @param {Number} savefileId the index of the savefile
 * @return {String} the path
 */
StorageManager.localFilePath = function(savefileId) {
    var name;
    if (savefileId &lt; 0) {
        name = 'config.rpgsave';
    } else if (savefileId === 0) {
        name = 'global.rpgsave';
    } else {
        name = 'file%1.rpgsave'.format(savefileId);
    }
    return this.localFileDirectoryPath() + name;
};

<span id='StorageManager-static-method-webStorageKey'>/**
</span> * @method webStorageKey
 * Get the key for a specific savefile.
 * @static
 * @param {Number} savefileId the index of the savefile
 * @return {String} the storage key
 */
StorageManager.webStorageKey = function(savefileId) {
    if (savefileId &lt; 0) {
        return 'RPG Config';
    } else if (savefileId === 0) {
        return 'RPG Global';
    } else {
        return 'RPG File%1'.format(savefileId);
    }
};

//-----------------------------------------------------------------------------
// ImageManager
//
// The static class that loads images, creates bitmap objects and retains them.

<span id='ImageManager-method-constructor'><span id='ImageManager'>/**
</span></span> * The static class that loads images, creates bitmap objects and retains them.
 * @class ImageManager
 * @uses Bitmap
 * @uses CacheMap
 * @uses ImageCache
 * @uses RequestQueue
 * @singleton
 * @static
 * @constructor should never be used
 *
 */
function ImageManager() {
    throw new Error('This is a static class');
}

<span id='ImageManager-static-property-cache'>/**
</span> * @property {CacheMap} cache
 * @static
 */
ImageManager.cache = new CacheMap(ImageManager);
<span id='ImageManager-static-property-_imageCache'>/**
</span> * @property {ImageCache} _imageCache
 * @static
 * @private
 */
ImageManager._imageCache = new ImageCache();
<span id='ImageManager-static-property-_requestQueue'>/**
</span> * @property {RequestQueue} _requestQueue
 * @static
 * @private
 */
ImageManager._requestQueue = new RequestQueue();
<span id='ImageManager-static-property-_systemReservationId'>/**
</span> * @property {Number} _systemReservationId
 * @static
 * @private
 */
ImageManager._systemReservationId = Utils.generateRuntimeId();

<span id='ImageManager-static-method-_generateCacheKey'>/**
</span> * @method _generateCacheKey
 * Generates the cache key for an image at a specific hue.
 * @static
 * @param {String} path the image path
 * @param {Number} hue the desired hue
 * @return {String}
 * @private
 */
ImageManager._generateCacheKey = function(path, hue){
    return  path + ':' + hue;
};

<span id='ImageManager-static-method-loadAnimation'>/**
</span> * @method loadAnimation
 * Loads an animation at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadAnimation = function(filename, hue) {
    return this.loadBitmap('img/animations/', filename, hue, true);
};

<span id='ImageManager-static-method-loadBattleback1'>/**
</span> * @method loadBattleback1
 * Loads a battleback at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadBattleback1 = function(filename, hue) {
    return this.loadBitmap('img/battlebacks1/', filename, hue, true);
};

<span id='ImageManager-static-method-loadBattleback2'>/**
</span> * @method loadBattleback2
 * Loads a battleback at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadBattleback2 = function(filename, hue) {
    return this.loadBitmap('img/battlebacks2/', filename, hue, true);
};

<span id='ImageManager-static-method-loadEnemy'>/**
</span> * @method loadEnemy
 * Loads an enemy graphic at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadEnemy = function(filename, hue) {
    return this.loadBitmap('img/enemies/', filename, hue, true);
};

<span id='ImageManager-static-method-loadCharacter'>/**
</span> * @method loadCharacter
 * Loads a character graphic at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadCharacter = function(filename, hue) {
    return this.loadBitmap('img/characters/', filename, hue, false);
};

<span id='ImageManager-static-method-loadFace'>/**
</span> * @method loadFace
 * Loads a face at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadFace = function(filename, hue) {
    return this.loadBitmap('img/faces/', filename, hue, true);
};

<span id='ImageManager-static-method-loadParallax'>/**
</span> * @method loadParallax
 * Loads a parallax at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadParallax = function(filename, hue) {
    return this.loadBitmap('img/parallaxes/', filename, hue, true);
};

<span id='ImageManager-static-method-loadPicture'>/**
</span> * @method loadPicture
 * Loads a picture at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadPicture = function(filename, hue) {
    return this.loadBitmap('img/pictures/', filename, hue, true);
};

<span id='ImageManager-static-method-loadSvActor1'>/**
</span> * @method loadSvActor1
 * Loads an sv actor at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadSvActor = function(filename, hue) {
    return this.loadBitmap('img/sv_actors/', filename, hue, false);
};

<span id='ImageManager-static-method-loadSvEnemy'>/**
</span> * @method loadSvEnemy
 * Loads an sv enemy at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadSvEnemy = function(filename, hue) {
    return this.loadBitmap('img/sv_enemies/', filename, hue, true);
};

<span id='ImageManager-static-method-loadSystem'>/**
</span> * @method loadSystem
 * Loads a system image at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadSystem = function(filename, hue) {
    return this.loadBitmap('img/system/', filename, hue, false);
};

<span id='ImageManager-static-method-loadTileset'>/**
</span> * @method loadTileset
 * Loads a tileset image at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadTileset = function(filename, hue) {
    return this.loadBitmap('img/tilesets/', filename, hue, false);
};

<span id='ImageManager-static-method-loadTitle1'>/**
</span> * @method loadTitle1
 * Loads a title image at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadTitle1 = function(filename, hue) {
    return this.loadBitmap('img/titles1/', filename, hue, true);
};

<span id='ImageManager-static-method-loadTitle1'>/**
</span> * @method loadTitle1
 * Loads a title image at a specified hue.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadTitle2 = function(filename, hue) {
    return this.loadBitmap('img/titles2/', filename, hue, true);
};

<span id='ImageManager-static-method-loadBitmap'>/**
</span> * @method loadBitmap
 * Loads a Bitmap at a specified hue.
 * @static
 * @param {String} folder the directory of images, ie 'img/titles1/'
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Boolean} smooth whether the image should be filtered
 * @return {Bitmap}
 */
ImageManager.loadBitmap = function(folder, filename, hue, smooth) {
    if (filename) {
        var path = folder + encodeURIComponent(filename) + '.png';
        var bitmap = this.loadNormalBitmap(path, hue || 0);
        bitmap.smooth = smooth;
        return bitmap;
    } else {
        return this.loadEmptyBitmap();
    }
};

<span id='ImageManager-static-method-loadEmptyBitmap'>/**
</span> * @method loadEmptyBitmap
 * Loads an empty Bitmap as a placeholder.
 * @static
 * @return {Bitmap}
 */
ImageManager.loadEmptyBitmap = function() {
    var empty = this._imageCache.get('empty');
    if(!empty){
        empty = new Bitmap();
        this._imageCache.add('empty', empty);
        this._imageCache.reserve('empty', empty, this._systemReservationId);
    }

    return empty;
};

<span id='ImageManager-static-method-loadNormalBitmap'>/**
</span> * @method loadNormalBitmap
 * Loads a Bitmap at a specified hue.
 * Checks ImageManager._imageCache for cached Bitmap before loading.
 * @static
 * @param {String} path the combined path of the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap}
 */
ImageManager.loadNormalBitmap = function(path, hue) {
    var key = this._generateCacheKey(path, hue);
    var bitmap = this._imageCache.get(key);
    if (!bitmap) {
        bitmap = Bitmap.load(path);
        bitmap.addLoadListener(function() {
            bitmap.rotateHue(hue);
        });
        this._imageCache.add(key, bitmap);
    }else if(!bitmap.isReady()){
        bitmap.decode();
    }

    return bitmap;
};

<span id='ImageManager-static-method-clear'>/**
</span> * @method clear
 * Clears ImageManager._imageCache.
 * @static
 */
ImageManager.clear = function() {
    this._imageCache = new ImageCache();
};

<span id='ImageManager-static-method-isReady'>/**
</span> * @method isReady
 * Checks if ImageManager._imageCache is ready.
 * @static
 */
ImageManager.isReady = function() {
    return this._imageCache.isReady();
};

<span id='ImageManager-static-method-isObjectCharacter'>/**
</span> * @method isObjectCharacter
 * Checks an image filename for '!',
 * meaning that it is a character sheet.
 * @static
 * @param {String} filename the image file
 */
ImageManager.isObjectCharacter = function(filename) {
    var sign = filename.match(/^[\!\$]+/);
    return sign &amp;&amp; sign[0].contains('!');
};

<span id='ImageManager-static-method-isBigCharacter'>/**
</span> * @method isBigCharacter
 * Checks an image filename for '$',
 * meaning that it is a big character sheet.
 * @static
 * @param {String} filename the image file
 */
ImageManager.isBigCharacter = function(filename) {
    var sign = filename.match(/^[\!\$]+/);
    return sign &amp;&amp; sign[0].contains('$');
};

<span id='ImageManager-static-method-isZeroParallax'>/**
</span> * @method isZeroParallax
 * Checks if an image name begins with '!',
 * meaning that it does not have parallax.
 * @static
 * @param {String} filename the image file
 */
ImageManager.isZeroParallax = function(filename) {
    return filename.charAt(0) === '!';
};

<span id='ImageManager-static-method-reserveAnimation'>/**
</span> * @method reserveAnimation
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveAnimation = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/animations/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveBattleback1'>/**
</span> * @method reserveBattleback1
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveBattleback1 = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/battlebacks1/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveBattleback2'>/**
</span> * @method reserveBattleback2
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveBattleback2 = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/battlebacks2/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveEnemy'>/**
</span> * @method reserveEnemy
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveEnemy = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/enemies/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveCharacter'>/**
</span> * @method reserveCharacter
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveCharacter = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/characters/', filename, hue, false, reservationId);
};

<span id='ImageManager-static-method-reserveFace'>/**
</span> * @method reserveFace
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveFace = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/faces/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveParallax'>/**
</span> * @method reserveParallax
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveParallax = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/parallaxes/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reservePicture'>/**
</span> * @method reservePicture
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reservePicture = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/pictures/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveSvActor'>/**
</span> * @method reserveSvActor
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveSvActor = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/sv_actors/', filename, hue, false, reservationId);
};

<span id='ImageManager-static-method-reserveSvEnemy'>/**
</span> * @method reserveSvEnemy
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveSvEnemy = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/sv_enemies/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveSystem'>/**
</span> * @method reserveSystem
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveSystem = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/system/', filename, hue, false, reservationId || this._systemReservationId);
};

<span id='ImageManager-static-method-reserveTileset'>/**
</span> * @method reserveTileset
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveTileset = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/tilesets/', filename, hue, false, reservationId);
};

<span id='ImageManager-static-method-reserveTitle1'>/**
</span> * @method reserveTitle1
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveTitle1 = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/titles1/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveTitle2'>/**
</span> * @method reserveTitle2
 * Loads a Bitmap.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveTitle2 = function(filename, hue, reservationId) {
    return this.reserveBitmap('img/titles2/', filename, hue, true, reservationId);
};

<span id='ImageManager-static-method-reserveBitmap'>/**
</span> * @method reserveBitmap
 * Loads a Bitmap and reserves it in ImageManager._imageCache
 * @static
 * @param {String} folder the directory of images
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Number} smooth whether to filter the image or not
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveBitmap = function(folder, filename, hue, smooth, reservationId) {
    if (filename) {
        var path = folder + encodeURIComponent(filename) + '.png';
        var bitmap = this.reserveNormalBitmap(path, hue || 0, reservationId || this._defaultReservationId);
        bitmap.smooth = smooth;
        return bitmap;
    } else {
        return this.loadEmptyBitmap();
    }
};

<span id='ImageManager-static-method-reserveNormalBitmap'>/**
</span> * @method reserveNormalBitmap
 * Reserve a Bitmap in ImageManager._imageCache
 * @static
 * @param {String} path the combined path of the image file
 * @param {Number} hue the desired hue
 * @param {Number} reservationId
 * @return {Bitmap}
 */
ImageManager.reserveNormalBitmap = function(path, hue, reservationId){
    var bitmap = this.loadNormalBitmap(path, hue);
    this._imageCache.reserve(this._generateCacheKey(path, hue), bitmap, reservationId);

    return bitmap;
};

<span id='ImageManager-static-method-releaseReservation'>/**
</span> * @method releaseReservation
 * Release an image's reservation from ImageManager._imageCache.
 * @static
 * @param {Number} reservationId
 */
ImageManager.releaseReservation = function(reservationId){
    this._imageCache.releaseReservation(reservationId);
};

<span id='ImageManager-static-method-setDefaultReservationId'>/**
</span> * @method setDefaultReservationId
 * Set the default reservationId
 * @static
 * @param {Number} reservationId
 */
ImageManager.setDefaultReservationId = function(reservationId){
    this._defaultReservationId = reservationId;
};

<span id='ImageManager-static-method-requestAnimation'>/**
</span> * @method requestAnimation
 * Ask for an animation image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestAnimation = function(filename, hue) {
    return this.requestBitmap('img/animations/', filename, hue, true);
};

<span id='ImageManager-static-method-requestBattleback1'>/**
</span> * @method requestBattleback1
 * Ask for a battleback image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestBattleback1 = function(filename, hue) {
    return this.requestBitmap('img/battlebacks1/', filename, hue, true);
};

<span id='ImageManager-static-method-requestBattleback2'>/**
</span> * @method requestBattleback2
 * Ask for a battleback image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestBattleback2 = function(filename, hue) {
    return this.requestBitmap('img/battlebacks2/', filename, hue, true);
};

<span id='ImageManager-static-method-requestEnemy'>/**
</span> * @method requestEnemy
 * Ask for an enemy image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestEnemy = function(filename, hue) {
    return this.requestBitmap('img/enemies/', filename, hue, true);
};

<span id='ImageManager-static-method-requestCharacter'>/**
</span> * @method requestCharacter
 * Ask for a character image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestCharacter = function(filename, hue) {
    return this.requestBitmap('img/characters/', filename, hue, false);
};

<span id='ImageManager-static-method-requestFace'>/**
</span> * @method requestFace
 * Ask for a face image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestFace = function(filename, hue) {
    return this.requestBitmap('img/faces/', filename, hue, true);
};

<span id='ImageManager-static-method-requestParallax'>/**
</span> * @method requestParallax
 * Ask for a parallax image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestParallax = function(filename, hue) {
    return this.requestBitmap('img/parallaxes/', filename, hue, true);
};

<span id='ImageManager-static-method-requestPicture'>/**
</span> * @method requestPicture
 * Ask for a picture image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestPicture = function(filename, hue) {
    return this.requestBitmap('img/pictures/', filename, hue, true);
};


<span id='ImageManager-static-method-requestSvActor'>/**
</span> * @method requestSvActor
 * Ask for an sv actor image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestSvActor = function(filename, hue) {
    return this.requestBitmap('img/sv_actors/', filename, hue, false);
};

<span id='ImageManager-static-method-requestSvEnemy'>/**
</span> * @method requestSvEnemy
 * Ask for an sv enemy image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestSvEnemy = function(filename, hue) {
    return this.requestBitmap('img/sv_enemies/', filename, hue, true);
};

<span id='ImageManager-static-method-requestSystem'>/**
</span> * @method requestSystem
 * Ask for a system image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestSystem = function(filename, hue) {
    return this.requestBitmap('img/system/', filename, hue, false);
};

<span id='ImageManager-static-method-requestTileset'>/**
</span> * @method requestTileset
 * Ask for a tileset image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestTileset = function(filename, hue) {
    return this.requestBitmap('img/tilesets/', filename, hue, false);
};

<span id='ImageManager-static-method-requestTitle1'>/**
</span> * @method requestTitle1
 * Ask for a title image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestTitle1 = function(filename, hue) {
    return this.requestBitmap('img/titles1/', filename, hue, true);
};

<span id='ImageManager-static-method-requestTitle2'>/**
</span> * @method requestTitle2
 * Ask for a title image.
 * @static
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestTitle2 = function(filename, hue) {
    return this.requestBitmap('img/titles2/', filename, hue, true);
};

<span id='ImageManager-static-method-requestBitmap'>/**
</span> * @method requestBitmap
 * Request a Bitmap to be loaded.
 * @static
 * @param {String} folder the directory of images
 * @param {String} filename the image file
 * @param {Number} hue the desired hue
 * @param {Boolean} smooth whether to filter the image
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestBitmap = function(folder, filename, hue, smooth) {
    if (filename) {
        var path = folder + encodeURIComponent(filename) + '.png';
        var bitmap = this.requestNormalBitmap(path, hue || 0);
        bitmap.smooth = smooth;
        return bitmap;
    } else {
        return this.loadEmptyBitmap();
    }
};

<span id='ImageManager-static-method-requestNormalBitmap'>/**
</span> * @method requestNormalBitmap
 * Request a Bitmap to be loaded.
 * An image already cached will have its priority escalated.
 * @static
 * @param {String} path the combined path of the image file
 * @param {Number} hue the desired hue
 * @return {Bitmap} the loaded Bitmap
 */
ImageManager.requestNormalBitmap = function(path, hue){
    var key = this._generateCacheKey(path, hue);
    var bitmap = this._imageCache.get(key);
    if(!bitmap){
        bitmap = Bitmap.request(path);
        bitmap.addLoadListener(function(){
            bitmap.rotateHue(hue);
        });
        this._imageCache.add(key, bitmap);
        this._requestQueue.enqueue(key, bitmap);
    }else{
        this._requestQueue.raisePriority(key);
    }

    return bitmap;
};

<span id='ImageManager-static-method-update'>/**
</span> * @method update
 * Updates ImageManager._requestQueue
 * @static
 */
ImageManager.update = function(){
    this._requestQueue.update();
};

<span id='ImageManager-static-method-clearRequest'>/**
</span> * @method clearRequest
 * Clears ImageManager._requestQueue
 * @static
 */
ImageManager.clearRequest = function(){
    this._requestQueue.clear();
};


//-----------------------------------------------------------------------------
// AudioManager
//
// The static class that handles BGM, BGS, ME and SE.


// NOTE: this code is ADDED so sound can be documented.
//       sound is not _actually_ a vanilla class,
//       but an object literal.
<span id='sound-method-constructor'><span id='sound'>/**
</span></span> * @class sound
 * The Object for representing sounds.
 * @constructor
 */
 function sound() {
     throw new Error('This is an object literal type');
 }
<span id='sound-property-name'>/**
</span> * @property {String} name the filename without extension
 */
<span id='sound-property-volume'>/**
</span> * @property {Number} volume [0,100]
 */
<span id='sound-property-pitch'>/**
</span> * @property {Number} pitch [50,150]
 */
<span id='sound-property-pan'>/**
</span> * @property {Number} pan [-100,100]
 */
<span id='sound-property-pos'>/**
</span> * @property {Number} pos in seconds
 */

<span id='AudioManager-method-constructor'><span id='AudioManager'>/**
</span></span> * @class AudioManager
 * The static class that handles BGM, BGS, ME and SE.
 * @uses sound
 * @uses WebAudio
 * @uses Html5Audio
 *
 * @static
 * @singleton
 * @constructor should never be used
 */
function AudioManager() {
    throw new Error('This is a static class');
}

<span id='AudioManager-static-property-_masterVolume'>/**
</span> * @property {Number} _masterVolume Range: [0.0,1.0]
 * @static
 * @private
 */
AudioManager._masterVolume   = 1;   // (min: 0, max: 1)
<span id='AudioManager-static-property-_bgmVolume'>/**
</span> * @property {Number} _bgmVolume Range: [0,100]
 * @static
 * @private
 */
AudioManager._bgmVolume      = 100;
<span id='AudioManager-static-property-_bgsVolume'>/**
</span> * @property {Number} _bgsVolume Range: [0,100]
 * @static
 * @private
 */
AudioManager._bgsVolume      = 100;
<span id='AudioManager-static-property-_meVolume'>/**
</span> * @property {Number} _meVolume Range: [0,100]
 * @static
 * @private
 */
AudioManager._meVolume       = 100;
<span id='AudioManager-static-property-_seVolume'>/**
</span> * @property {Number} _seVolume Range: [0,100]
 * @static
 * @private
 */
AudioManager._seVolume       = 100;
<span id='AudioManager-static-property-_currentBgm'>/**
</span> * @property {sound} _currentBgm
 * @static
 * @private
 */
AudioManager._currentBgm     = null;
<span id='AudioManager-static-property-_currentBgs'>/**
</span> * @property {sound} _currentBgs
 * @static
 * @private
 */
AudioManager._currentBgs     = null;
<span id='AudioManager-static-property-_bgmBuffer'>/**
</span> * @property {WebAudio|Html5Audio} _bgmBuffer
 * @static
 * @private
 */
AudioManager._bgmBuffer      = null;
<span id='AudioManager-static-property-_bgsBuffer'>/**
</span> * @property {WebAudio|Html5Audio} _bgsBuffer
 * @static
 * @private
 */
AudioManager._bgsBuffer      = null;
<span id='AudioManager-static-property-_meBuffer'>/**
</span> * @property {WebAudio|Html5Audio} _meBuffer
 * @static
 * @private
 */
AudioManager._meBuffer       = null;
<span id='AudioManager-static-property-_seBuffers'>/**
</span> * @property {WebAudio[]|Html5Audio[]}_seBuffers
 * @static
 * @private
 */
AudioManager._seBuffers      = [];
<span id='AudioManager-static-property-_staticBuffers'>/**
</span> * @property {WebAudio[]|Html5Audio[]} _staticBuffers
 * @static
 * @private
 */
AudioManager._staticBuffers  = [];
<span id='AudioManager-static-property-_replayFadeTime'>/**
</span> * @property {Number} _replayFadeTime
 * @static
 * @private
 */
AudioManager._replayFadeTime = 0.5;
<span id='AudioManager-static-property-_path'>/**
</span> * @property {String} _path
 * the path to your project's audio/ directory
 * @static
 * @private
 */
AudioManager._path           = 'audio/';
<span id='AudioManager-static-property-_blobUrl'>/**
</span> * @property {String} _blobUrl
 * @static
 * @private
 */
AudioManager._blobUrl        = null;

<span id='AudioManager-static-property-masterVolume'>/**
</span> * @property {Number} masterVolume Range: [0.0,1.0]
 * @static
 */
Object.defineProperty(AudioManager, 'masterVolume', {
    get: function() {
        return this._masterVolume;
    },
    set: function(value) {
        this._masterVolume = value;
        WebAudio.setMasterVolume(this._masterVolume);
        Graphics.setVideoVolume(this._masterVolume);
    },
    configurable: true
});

<span id='AudioManager-static-property-bgmVolume'>/**
</span> * @property {Number} bgmVolume Range: [0,100]
 * @static
 */
Object.defineProperty(AudioManager, 'bgmVolume', {
    get: function() {
        return this._bgmVolume;
    },
    set: function(value) {
        this._bgmVolume = value;
        this.updateBgmParameters(this._currentBgm);
    },
    configurable: true
});

<span id='AudioManager-static-property-bgsVolume'>/**
</span> * @property {Number} bgsVolume Range: [0,100]
 * @static
 */
Object.defineProperty(AudioManager, 'bgsVolume', {
    get: function() {
        return this._bgsVolume;
    },
    set: function(value) {
        this._bgsVolume = value;
        this.updateBgsParameters(this._currentBgs);
    },
    configurable: true
});

<span id='AudioManager-static-property-meVolume'>/**
</span> * @property {Number} meVolume Range: [0,100]
 * @static
 */
Object.defineProperty(AudioManager, 'meVolume', {
    get: function() {
        return this._meVolume;
    },
    set: function(value) {
        this._meVolume = value;
        this.updateMeParameters(this._currentMe);
    },
    configurable: true
});

<span id='AudioManager-static-property-seVolume'>/**
</span> * @property {Number} seVolume Range: [0,100]
 * @static
 */
Object.defineProperty(AudioManager, 'seVolume', {
    get: function() {
        return this._seVolume;
    },
    set: function(value) {
        this._seVolume = value;
    },
    configurable: true
});

<span id='AudioManager-static-method-playBgm'>/**
</span> * @method playBgm
 * Play a BGM
 * @static
 * @param {sound} bgm the bgm you want to play
 * @param {Number} pos the position to play from, in seconds
 */
AudioManager.playBgm = function(bgm, pos) {
    if (this.isCurrentBgm(bgm)) {
        this.updateBgmParameters(bgm);
    } else {
        this.stopBgm();
        if (bgm.name) {
            if(Decrypter.hasEncryptedAudio &amp;&amp; this.shouldUseHtml5Audio()){
                this.playEncryptedBgm(bgm, pos);
            }
            else {
                this._bgmBuffer = this.createBuffer('bgm', bgm.name);
                this.updateBgmParameters(bgm);
                if (!this._meBuffer) {
                    this._bgmBuffer.play(true, pos || 0);
                }
            }
        }
    }
    this.updateCurrentBgm(bgm, pos);
};

<span id='AudioManager-static-method-playEncryptedBgm'>/**
</span> * @method playEncryptedBgm
 * Play an encrypted BGM
 * @static
 * @param {sound} bgm the bgm you want to play
 * @param {Number} pos the position to play from, in seconds
 */
AudioManager.playEncryptedBgm = function(bgm, pos) {
    var ext = this.audioFileExt();
    var url = this._path + 'bgm/' + encodeURIComponent(bgm.name) + ext;
    url = Decrypter.extToEncryptExt(url);
    Decrypter.decryptHTML5Audio(url, bgm, pos);
};

<span id='AudioManager-static-method-createDecryptBuffer'>/**
</span> * @method createDecryptBuffer
 * Creates a buffer for BGM playback.
 * Plays the BGM if no ME is playing.
 * @static
 * @param {String} url the url from AudioManager._blobUrl
 * @param {sound} bgm the BGM to play
 * @param {Number} pos the position to play from, in seconds
 */
AudioManager.createDecryptBuffer = function(url, bgm, pos){
    this._blobUrl = url;
    this._bgmBuffer = this.createBuffer('bgm', bgm.name);
    this.updateBgmParameters(bgm);
    if (!this._meBuffer) {
        this._bgmBuffer.play(true, pos || 0);
    }
    this.updateCurrentBgm(bgm, pos);
};

<span id='AudioManager-static-method-replayBgm'>/**
</span> * @method replayBgm
 * Update the current BGM if it was passed in,
 * else fade into the new BGM.
 * @static
 * @param {sound} bgm the BGM to replay
 */
AudioManager.replayBgm = function(bgm) {
    if (this.isCurrentBgm(bgm)) {
        this.updateBgmParameters(bgm);
    } else {
        this.playBgm(bgm, bgm.pos);
        if (this._bgmBuffer) {
            this._bgmBuffer.fadeIn(this._replayFadeTime);
        }
    }
};

<span id='AudioManager-static-method-isCurrentBgm'>/**
</span> * @method isCurrentBgm
 * Check if a specified BGM is the current one.
 * @static
 * @param {sound} bgm the BGM to check
 * @return {Boolean}
 */
AudioManager.isCurrentBgm = function(bgm) {
    return (this._currentBgm &amp;&amp; this._bgmBuffer &amp;&amp;
            this._currentBgm.name === bgm.name);
};

<span id='AudioManager-static-method-updateBgmParameters'>/**
</span> * @method updateBgmParameters
 * Update AudioManager._bgmBuffer with the BGM given.
 * @static
 * @param {sound} bgm the BGM to use
 */
AudioManager.updateBgmParameters = function(bgm) {
    this.updateBufferParameters(this._bgmBuffer, this._bgmVolume, bgm);
};

<span id='AudioManager-static-method-updateCurrentBgm'>/**
</span> * @method updateCurrentBgm
 * Update AudioManager._currentBgm to the new bgm.
 * @static
 * @param {sound} bgm the BGM to use
 * @param {Number} pos the position to play from, in seconds
 */
AudioManager.updateCurrentBgm = function(bgm, pos) {
    this._currentBgm = {
        name: bgm.name,
        volume: bgm.volume,
        pitch: bgm.pitch,
        pan: bgm.pan,
        pos: pos
    };
};

<span id='AudioManager-static-method-stopBgm'>/**
</span> * @method stopBgm
 * Stops and clears AudioManager._bgmBuffer
 * @static
 */
AudioManager.stopBgm = function() {
    if (this._bgmBuffer) {
        this._bgmBuffer.stop();
        this._bgmBuffer = null;
        this._currentBgm = null;
    }
};

<span id='AudioManager-static-method-fadeOutBgm'>/**
</span> * @method fadeOutBgm
 * Fade out the current BGM.
 * @static
 * @param {Number} duration how long to fade out, in seconds
 */
AudioManager.fadeOutBgm = function(duration) {
    if (this._bgmBuffer &amp;&amp; this._currentBgm) {
        this._bgmBuffer.fadeOut(duration);
        this._currentBgm = null;
    }
};

<span id='AudioManager-static-method-fadeInBgm'>/**
</span> * @method fadeInBgm
 * Fade in the current BGM.
 * @static
 * @param {Number} duration how long to fade out, in seconds
 */
AudioManager.fadeInBgm = function(duration) {
    if (this._bgmBuffer &amp;&amp; this._currentBgm) {
        this._bgmBuffer.fadeIn(duration);
    }
};

<span id='AudioManager-static-method-playBgs'>/**
</span> * @method playBgs
 * Play a BGS.
 * @static
 * @param {sound} bgs the BGS to play
 * @param {Number} pos the position to play from, in seconds
 */
AudioManager.playBgs = function(bgs, pos) {
    if (this.isCurrentBgs(bgs)) {
        this.updateBgsParameters(bgs);
    } else {
        this.stopBgs();
        if (bgs.name) {
            this._bgsBuffer = this.createBuffer('bgs', bgs.name);
            this.updateBgsParameters(bgs);
            this._bgsBuffer.play(true, pos || 0);
        }
    }
    this.updateCurrentBgs(bgs, pos);
};

<span id='AudioManager-static-method-replayBgs'>/**
</span> * @method replayBgs
 * Replay a BGS.
 * @static
 * @param {sound} bgs the BGS to replay
 */
AudioManager.replayBgs = function(bgs) {
    if (this.isCurrentBgs(bgs)) {
        this.updateBgsParameters(bgs);
    } else {
        this.playBgs(bgs, bgs.pos);
        if (this._bgsBuffer) {
            this._bgsBuffer.fadeIn(this._replayFadeTime);
        }
    }
};

<span id='AudioManager-static-method-isCurrentBgs'>/**
</span> * @method isCurrentBgs
 * Check if a BGS is the current one
 * @static
 * @param {sound} bgs the BGS to check
 * @return {Boolean}
 */
AudioManager.isCurrentBgs = function(bgs) {
    return (this._currentBgs &amp;&amp; this._bgsBuffer &amp;&amp;
            this._currentBgs.name === bgs.name);
};

<span id='AudioManager-static-method-updateBgsParameters'>/**
</span> * @method updateBgsParameters
 * Update AudioManager._bgsBuffer with a BGS object
 * @static
 * @param {sound} bgs the BGS to use
 */
AudioManager.updateBgsParameters = function(bgs) {
    this.updateBufferParameters(this._bgsBuffer, this._bgsVolume, bgs);
};

<span id='AudioManager-static-method-updateCurrentBgs'>/**
</span> * @method updateCurrentBgs
 * Update AudioManager._currentBgm with a BGS object
 * @static
 * @param {sound} bgs the BGS to use
 * @param {Number} pos the position to play from, in seconds
 */
AudioManager.updateCurrentBgs = function(bgs, pos) {
    this._currentBgs = {
        name: bgs.name,
        volume: bgs.volume,
        pitch: bgs.pitch,
        pan: bgs.pan,
        pos: pos
    };
};

<span id='AudioManager-static-method-stopBgs'>/**
</span> * @method stopBgs
 * Stop the current BGS and clear AudioManager._bgsBuffer
 * @static
 */
AudioManager.stopBgs = function() {
    if (this._bgsBuffer) {
        this._bgsBuffer.stop();
        this._bgsBuffer = null;
        this._currentBgs = null;
    }
};

<span id='AudioManager-static-method-fadeOutBgs'>/**
</span> * @method fadeOutBgs
 * Fade out the current BGS
 * @static
 * @param {Number} duration the fade duration in seconds
 */
AudioManager.fadeOutBgs = function(duration) {
    if (this._bgsBuffer &amp;&amp; this._currentBgs) {
        this._bgsBuffer.fadeOut(duration);
        this._currentBgs = null;
    }
};

<span id='AudioManager-static-method-fadeInBgs'>/**
</span> * @method fadeInBgs
 * Fade in the current BGS.
 * @static
 * @param {Number} duration the fade in duration in seconds
 */
AudioManager.fadeInBgs = function(duration) {
    if (this._bgsBuffer &amp;&amp; this._currentBgs) {
        this._bgsBuffer.fadeIn(duration);
    }
};

<span id='AudioManager-static-method-playMe'>/**
</span> * @method playMe
 * Stops the current ME. Pauses the BGM. Plays the new ME.
 * @static
 * @param {sound} me the ME to play
 */
AudioManager.playMe = function(me) {
    this.stopMe();
    if (me.name) {
        if (this._bgmBuffer &amp;&amp; this._currentBgm) {
            this._currentBgm.pos = this._bgmBuffer.seek();
            this._bgmBuffer.stop();
        }
        this._meBuffer = this.createBuffer('me', me.name);
        this.updateMeParameters(me);
        this._meBuffer.play(false);
        this._meBuffer.addStopListener(this.stopMe.bind(this));
    }
};

<span id='AudioManager-static-method-updateMeParameters'>/**
</span> * @method updateMeParameters
 * Updates AudioManager._meBuffer with an ME
 * @static
 * @param {sound} me the ME to play
 */
AudioManager.updateMeParameters = function(me) {
    this.updateBufferParameters(this._meBuffer, this._meVolume, me);
};

<span id='AudioManager-static-method-updateMeParameters'>/**
</span> * @method updateMeParameters
 * Fade out the current ME.
 * @static
 * @param {Number} duration the fade duration in seconds
 */
AudioManager.fadeOutMe = function(duration) {
    if (this._meBuffer) {
        this._meBuffer.fadeOut(duration);
    }
};

<span id='AudioManager-static-method-stopMe'>/**
</span> * @method stopMe
 * Stop the current ME and clear AudioManager._meBuffer.
 * Also resumes the BGM, if one was playing.
 * @static
 */
AudioManager.stopMe = function() {
    if (this._meBuffer) {
        this._meBuffer.stop();
        this._meBuffer = null;
        if (this._bgmBuffer &amp;&amp; this._currentBgm &amp;&amp; !this._bgmBuffer.isPlaying()) {
            this._bgmBuffer.play(true, this._currentBgm.pos);
            this._bgmBuffer.fadeIn(this._replayFadeTime);
        }
    }
};

<span id='AudioManager-static-method-playSe'>/**
</span> * @method playSe
 * Play an SE.
 * @static
 * @param {sound} se the SE to play
 */
AudioManager.playSe = function(se) {
    if (se.name) {
        this._seBuffers = this._seBuffers.filter(function(audio) {
            return audio.isPlaying();
        });
        var buffer = this.createBuffer('se', se.name);
        this.updateSeParameters(buffer, se);
        buffer.play(false);
        this._seBuffers.push(buffer);
    }
};

<span id='AudioManager-static-method-updateSeParameters'>/**
</span> * @method updateSeParameters
 * Updates a buffer with an SE.
 * @static
 * @param {WebAudio|Html5Audio} buffer the buffer to update
 * @param {sound} se the SE to apply to the buffer
 */
AudioManager.updateSeParameters = function(buffer, se) {
    this.updateBufferParameters(buffer, this._seVolume, se);
};

<span id='AudioManager-static-method-stopSe'>/**
</span> * @method stopSe
 * Stops every SE currently playing.
 * Clears every buffer in AudioManager._seBuffers
 * @static
 */
AudioManager.stopSe = function() {
    this._seBuffers.forEach(function(buffer) {
        buffer.stop();
    });
    this._seBuffers = [];
};

<span id='AudioManager-static-method-playStaticSe'>/**
</span> * @method playStaticSe
 * Plays an SE with a static buffer.
 * @static
 * @param {sound} se the SE to play
 */
AudioManager.playStaticSe = function(se) {
    if (se.name) {
        this.loadStaticSe(se);
        for (var i = 0; i &lt; this._staticBuffers.length; i++) {
            var buffer = this._staticBuffers[i];
            if (buffer._reservedSeName === se.name) {
                buffer.stop();
                this.updateSeParameters(buffer, se);
                buffer.play(false);
                break;
            }
        }
    }
};

<span id='AudioManager-static-method-loadStaticSe'>/**
</span> * @method loadStaticSe
 * Loads an SE to be played on a static buffer.
 * Creates a static buffer to use for playback.
 * @static
 * @param {sound} se the SE to load
 */
AudioManager.loadStaticSe = function(se) {
    if (se.name &amp;&amp; !this.isStaticSe(se)) {
        var buffer = this.createBuffer('se', se.name);
        buffer._reservedSeName = se.name;
        this._staticBuffers.push(buffer);
        if (this.shouldUseHtml5Audio()) {
            Html5Audio.setStaticSe(buffer._url);
        }
    }
};

<span id='AudioManager-static-method-isStaticSe'>/**
</span> * @method isStaticSe
 * Checks if a static buffer exists for this SE.
 * @static
 * @param {sound} se the SE to check
 * @return {Boolean}
 */
AudioManager.isStaticSe = function(se) {
    for (var i = 0; i &lt; this._staticBuffers.length; i++) {
        var buffer = this._staticBuffers[i];
        if (buffer._reservedSeName === se.name) {
            return true;
        }
    }
    return false;
};

<span id='AudioManager-static-method-stopAll'>/**
</span> * @method stopAll
 * Stops all ME, BGM, BGS, and SE.
 * @static
 */
AudioManager.stopAll = function() {
    this.stopMe();
    this.stopBgm();
    this.stopBgs();
    this.stopSe();
};

<span id='AudioManager-static-method-saveBgm'>/**
</span> * @method saveBgm
 * Returns a sound of the current BGM, or an empty sound if
 * no BGM is playing.
 * @static
 * @return {sound}
 */
AudioManager.saveBgm = function() {
    if (this._currentBgm) {
        var bgm = this._currentBgm;
        return {
            name: bgm.name,
            volume: bgm.volume,
            pitch: bgm.pitch,
            pan: bgm.pan,
            pos: this._bgmBuffer ? this._bgmBuffer.seek() : 0
        };
    } else {
        return this.makeEmptyAudioObject();
    }
};

<span id='AudioManager-static-method-saveBgs'>/**
</span> * @method saveBgs
 * Returns a sound of the current BGS, or an empty sound if
 * no BGM is playing.
 * @static
 * @return {sound}
 */
AudioManager.saveBgs = function() {
    if (this._currentBgs) {
        var bgs = this._currentBgs;
        return {
            name: bgs.name,
            volume: bgs.volume,
            pitch: bgs.pitch,
            pan: bgs.pan,
            pos: this._bgsBuffer ? this._bgsBuffer.seek() : 0
        };
    } else {
        return this.makeEmptyAudioObject();
    }
};

<span id='AudioManager-static-method-makeEmptyAudioObject'>/**
</span> * @method makeEmptyAudioObject
 * Returns an empty sound object of
 * the form { name: '', volume: 0, pitch: 0 }.
 * @static
 * @return {sound}
 */
AudioManager.makeEmptyAudioObject = function() {
    return { name: '', volume: 0, pitch: 0 };
};

<span id='AudioManager-static-method-createBuffer'>/**
</span> * @method createBuffer
 * Returns either a WebAudio instance or a ref to Html5Audio.
 * @static
 * @param {String} folder the directory of audio files
 * @param {String} name the name of the audio file, without extension
 * @return {WebAudio|Html5Audio}
 */
AudioManager.createBuffer = function(folder, name) {
    var ext = this.audioFileExt();
    var url = this._path + folder + '/' + encodeURIComponent(name) + ext;
    if (this.shouldUseHtml5Audio() &amp;&amp; folder === 'bgm') {
        if(this._blobUrl) Html5Audio.setup(this._blobUrl);
        else Html5Audio.setup(url);
        return Html5Audio;
    } else {
        return new WebAudio(url);
    }
};

<span id='AudioManager-static-method-updateBufferParameters'>/**
</span> * @method updateBufferParameters
 * Updates the volume, pitch, and pan of the buffer.
 * @static
 * @param {WebAudio|Html5Audio} buffer the buffer to update
 * @param {Number} configVolume
 * @param {FIXME} audio
 */
AudioManager.updateBufferParameters = function(buffer, configVolume, audio) {
    if (buffer &amp;&amp; audio) {
        buffer.volume = configVolume * (audio.volume || 0) / 10000;
        buffer.pitch = (audio.pitch || 0) / 100;
        buffer.pan = (audio.pan || 0) / 100;
    }
};

<span id='AudioManager-static-method-audioFileExt'>/**
</span> * @method audioFileExt
 * Gets the audio extension used by the platform.
 * @static
 * @return {String} '.ogg' or '.m4a'
 */
AudioManager.audioFileExt = function() {
    if (WebAudio.canPlayOgg() &amp;&amp; !Utils.isMobileDevice()) {
        return '.ogg';
    } else {
        return '.m4a';
    }
};

<span id='AudioManager-static-method-shouldUseHtml5Audio'>/**
</span> * @method shouldUseHtml5Audio
 * Always returns false. So Html5Audio is _never_ used.
 * This means that all buffers are WebAudio instances.
 * @static
 * @return {Boolean}
 */
AudioManager.shouldUseHtml5Audio = function() {
    // The only case where we wanted html5audio was android/ no encrypt
    // Atsuma-ru asked to force webaudio there too, so just return false for ALL    // return Utils.isAndroidChrome() &amp;&amp; !Decrypter.hasEncryptedAudio;
 return false;
};

<span id='AudioManager-static-method-checkErrors'>/**
</span> * @method checkErrors
 * Checks for errors in all audio buffers using
 * AudioManager.checkWebAudioError
 * @static
 */
AudioManager.checkErrors = function() {
    this.checkWebAudioError(this._bgmBuffer);
    this.checkWebAudioError(this._bgsBuffer);
    this.checkWebAudioError(this._meBuffer);
    this._seBuffers.forEach(function(buffer) {
        this.checkWebAudioError(buffer);
    }.bind(this));
    this._staticBuffers.forEach(function(buffer) {
        this.checkWebAudioError(buffer);
    }.bind(this));
};

<span id='AudioManager-static-method-checkWebAudioError'>/**
</span> * @method checkWebAudioError
 * Checks an audio buffer for errors, throws any found.
 * @static
 * @param {WebAudio} webAudio the buffer to check
 */
AudioManager.checkWebAudioError = function(webAudio) {
    if (webAudio &amp;&amp; webAudio.isError()) {
        throw new Error('Failed to load: ' + webAudio.url);
    }
};

//-----------------------------------------------------------------------------
// SoundManager
//
// The static class that plays sound effects defined in the database.

<span id='SoundManager-method-constructor'><span id='SoundManager'>/**
</span></span> * @class SoundManager
 * The static class that plays sound effects defined in the database.
 * @static
 * @uses AudioManager
 * @uses $dataSystem
 * @singleton
 * @static
 * @constructor should never be used
 */
function SoundManager() {
    throw new Error('This is a static class');
}

<span id='SoundManager-static-method-preloadImportantSounds'>/**
</span> * @method preloadImportantSounds
 * Loads system sounds 0..3.
 * @static
 */
SoundManager.preloadImportantSounds = function() {
    this.loadSystemSound(0);
    this.loadSystemSound(1);
    this.loadSystemSound(2);
    this.loadSystemSound(3);
};

<span id='SoundManager-static-method-loadSystemSound'>/**
</span> * @method loadSystemSound
 * Loads a system sound from $dataSystem.sounds by index.
 * Uses AudioManager.loadStaticSe
 * @static
 * @param {Number} n the sound to load
 */
SoundManager.loadSystemSound = function(n) {
    if ($dataSystem) {
        AudioManager.loadStaticSe($dataSystem.sounds[n]);
    }
};

<span id='SoundManager-static-method-playSystemSound'>/**
</span> * @method playSystemSound
 * Plays a system sound by index.
 * Uses AudioManager.playStaticSe
 * @static
 * @param {Number} n the sound to play
 */
SoundManager.playSystemSound = function(n) {
    if ($dataSystem) {
        AudioManager.playStaticSe($dataSystem.sounds[n]);
    }
};

<span id='SoundManager-static-method-playCursor'>/**
</span> * @method playCursor
 * Plays the Cursor sound (system sound 0)
 * @static
 */
SoundManager.playCursor = function() {
    this.playSystemSound(0);
};

<span id='SoundManager-static-method-playOk'>/**
</span> * @method playOk
 * Plays the Ok sound (system sound 1)
 * @static
 */
SoundManager.playOk = function() {
    this.playSystemSound(1);
};

<span id='SoundManager-static-method-playCancel'>/**
</span> * @method playCancel
 * Plays the Cancel sound (system sound 2)
 * @static
 */
SoundManager.playCancel = function() {
    this.playSystemSound(2);
};

<span id='SoundManager-static-method-playBuzzer'>/**
</span> * @method playBuzzer
 * Plays the Buzzer sound (system sound 3)
 * @static
 */
SoundManager.playBuzzer = function() {
    this.playSystemSound(3);
};

<span id='SoundManager-static-method-playEquip'>/**
</span> * @method playEquip
 * Plays the Equip sound (system sound 4)
 * @static
 */
SoundManager.playEquip = function() {
    this.playSystemSound(4);
};

<span id='SoundManager-static-method-playSave'>/**
</span> * @method playSave
 * Plays the Save sound (system sound 5)
 * @static
 */
SoundManager.playSave = function() {
    this.playSystemSound(5);
};

<span id='SoundManager-static-method-playLoad'>/**
</span> * @method playLoad
 * Plays the Load sound (system sound 6)
 * @static
 */
SoundManager.playLoad = function() {
    this.playSystemSound(6);
};

<span id='SoundManager-static-method-playBattleStart'>/**
</span> * @method playBattleStart
 * Plays the BattleStart sound (system sound 7)
 * @static
 */
SoundManager.playBattleStart = function() {
    this.playSystemSound(7);
};

<span id='SoundManager-static-method-playEscape'>/**
</span> * @method playEscape
 * Plays the Escape sound (system sound 8)
 * @static
 */
SoundManager.playEscape = function() {
    this.playSystemSound(8);
};

<span id='SoundManager-static-method-playEnemyAttack'>/**
</span> * @method playEnemyAttack
 * Plays the EnemyAttack sound (system sound 9)
 * @static
 */
SoundManager.playEnemyAttack = function() {
    this.playSystemSound(9);
};

<span id='SoundManager-static-method-playEnemyDamage'>/**
</span> * @method playEnemyDamage
 * Plays the EnemyDamage sound (system sound 10)
 * @static
 */
SoundManager.playEnemyDamage = function() {
    this.playSystemSound(10);
};

<span id='SoundManager-static-method-playEnemyCollapse'>/**
</span> * @method playEnemyCollapse
 * Plays the EnemyCollapse sound (system sound 11)
 * @static
 */
SoundManager.playEnemyCollapse = function() {
    this.playSystemSound(11);
};

<span id='SoundManager-static-method-playBossCollapse1'>/**
</span> * @method playBossCollapse1
 * Plays the BossCollapse1 sound (system sound 12)
 * @static
 */
SoundManager.playBossCollapse1 = function() {
    this.playSystemSound(12);
};

<span id='SoundManager-static-method-playBossCollapse2'>/**
</span> * @method playBossCollapse2
 * Plays the BossCollapse2 sound (system sound 13)
 * @static
 */
SoundManager.playBossCollapse2 = function() {
    this.playSystemSound(13);
};

<span id='SoundManager-static-method-playActorDamage'>/**
</span> * @method playActorDamage
 * Plays the ActorDamage sound (system sound 14)
 * @static
 */
SoundManager.playActorDamage = function() {
    this.playSystemSound(14);
};

<span id='SoundManager-static-method-playActorCollapse'>/**
</span> * @method playActorCollapse
 * Plays the ActorCollapse sound (system sound 15)
 * @static
 */
SoundManager.playActorCollapse = function() {
    this.playSystemSound(15);
};

<span id='SoundManager-static-method-playRecovery'>/**
</span> * @method playRecovery
 * Plays the Recovery sound (system sound 16)
 * @static
 */
SoundManager.playRecovery = function() {
    this.playSystemSound(16);
};

<span id='SoundManager-static-method-playMiss'>/**
</span> * @method playMiss
 * Plays the Miss sound (system sound 17)
 * @static
 */
SoundManager.playMiss = function() {
    this.playSystemSound(17);
};

<span id='SoundManager-static-method-playEvasion'>/**
</span> * @method playEvasion
 * Plays the Evasion sound (system sound 18)
 * @static
 */
SoundManager.playEvasion = function() {
    this.playSystemSound(18);
};

<span id='SoundManager-static-method-playMagicEvasion'>/**
</span> * @method playMagicEvasion
 * Plays the MagicEvasion sound (system sound 19)
 * @static
 */
SoundManager.playMagicEvasion = function() {
    this.playSystemSound(19);
};

<span id='SoundManager-static-method-playReflection'>/**
</span> * @method playReflection
 * Plays the Reflection sound (system sound 20)
 * @static
 */
SoundManager.playReflection = function() {
    this.playSystemSound(20);
};

<span id='SoundManager-static-method-playShop'>/**
</span> * @method playShop
 * Plays the Shop sound (system sound 21)
 * @static
 */
SoundManager.playShop = function() {
    this.playSystemSound(21);
};

<span id='SoundManager-static-method-playUseItem'>/**
</span> * @method playUseItem
 * Plays the UseItem sound (system sound 22)
 * @static
 */
SoundManager.playUseItem = function() {
    this.playSystemSound(22);
};

<span id='SoundManager-static-method-playUseSkill'>/**
</span> * @method playUseSkill
 * Plays the UseSkill sound (system sound 23)
 * @static
 */
SoundManager.playUseSkill = function() {
    this.playSystemSound(23);
};

//-----------------------------------------------------------------------------
// TextManager
//
// The static class that handles terms and messages.

<span id='TextManager-method-constructor'><span id='TextManager'>/**
</span></span> * @class TextManager
 * The static class that handles terms and messages.
 * @uses $dataSystem
 * @singleton
 * @static
 * @constructor should never be used
 */
function TextManager() {
    throw new Error('This is a static class');
}

<span id='TextManager-static-method-basic'>/**
</span> * @method basic
 * Gets a term from Basic Statuses in the Database
 * @param {String} basicId which term
 * @return {String} the term set in Database
 * @static
 */
TextManager.basic = function(basicId) {
    return $dataSystem.terms.basic[basicId] || '';
};

<span id='TextManager-static-method-param'>/**
</span> * @method param
 * Gets a term from Parameters in the Database
 * @param {String} paramId which term
 * @return {String} the term set in Database
 * @static
 */
TextManager.param = function(paramId) {
    return $dataSystem.terms.params[paramId] || '';
};

<span id='TextManager-static-method-command'>/**
</span> * @method command
 * Gets a term from Commands in the Database
 * @param {String} commandId which term
 * @return {String} the term set in Database
 * @static
 */
TextManager.command = function(commandId) {
    return $dataSystem.terms.commands[commandId] || '';
};

<span id='TextManager-static-method-message'>/**
</span> * @method message
 * Gets a term from Messages in the Database
 * @param {String} messageId which term
 * @return {String} the term set in Database
 * @static
 */
TextManager.message = function(messageId) {
    return $dataSystem.terms.messages[messageId] || '';
};

<span id='TextManager-static-method-getter'>/**
</span> * [read-only] @method getter
 * Used to create a read-only property for _every_ Term in the Database.
 * @param {String} method 'basic', 'command', or 'message'
 * @param {String|Number} param the ID or name of the Term
 * @return {String} the value of the Term
 * @static
 */
TextManager.getter = function(method, param) {
    return {
        get: function() {
            return this[method](param);
        },
        configurable: true
    };
};

<span id='TextManager-static-property-currencyUnit'>/**
</span> * [read-only] @property {String} currencyUnit
 * @static
 */
Object.defineProperty(TextManager, 'currencyUnit', {
    get: function() { return $dataSystem.currencyUnit; },
    configurable: true
});

/*
TODO: codegen doc comments for these properties lol
*/
Object.defineProperties(TextManager, {
    level           : TextManager.getter('basic', 0),
    levelA          : TextManager.getter('basic', 1),
    hp              : TextManager.getter('basic', 2),
    hpA             : TextManager.getter('basic', 3),
    mp              : TextManager.getter('basic', 4),
    mpA             : TextManager.getter('basic', 5),
    tp              : TextManager.getter('basic', 6),
    tpA             : TextManager.getter('basic', 7),
    exp             : TextManager.getter('basic', 8),
    expA            : TextManager.getter('basic', 9),
    fight           : TextManager.getter('command', 0),
    escape          : TextManager.getter('command', 1),
    attack          : TextManager.getter('command', 2),
    guard           : TextManager.getter('command', 3),
    item            : TextManager.getter('command', 4),
    skill           : TextManager.getter('command', 5),
    equip           : TextManager.getter('command', 6),
    status          : TextManager.getter('command', 7),
    formation       : TextManager.getter('command', 8),
    save            : TextManager.getter('command', 9),
    gameEnd         : TextManager.getter('command', 10),
    options         : TextManager.getter('command', 11),
    weapon          : TextManager.getter('command', 12),
    armor           : TextManager.getter('command', 13),
    keyItem         : TextManager.getter('command', 14),
    equip2          : TextManager.getter('command', 15),
    optimize        : TextManager.getter('command', 16),
    clear           : TextManager.getter('command', 17),
    newGame         : TextManager.getter('command', 18),
    continue_       : TextManager.getter('command', 19),
    toTitle         : TextManager.getter('command', 21),
    cancel          : TextManager.getter('command', 22),
    buy             : TextManager.getter('command', 24),
    sell            : TextManager.getter('command', 25),
    alwaysDash      : TextManager.getter('message', 'alwaysDash'),
    commandRemember : TextManager.getter('message', 'commandRemember'),
    bgmVolume       : TextManager.getter('message', 'bgmVolume'),
    bgsVolume       : TextManager.getter('message', 'bgsVolume'),
    meVolume        : TextManager.getter('message', 'meVolume'),
    seVolume        : TextManager.getter('message', 'seVolume'),
    possession      : TextManager.getter('message', 'possession'),
    expTotal        : TextManager.getter('message', 'expTotal'),
    expNext         : TextManager.getter('message', 'expNext'),
    saveMessage     : TextManager.getter('message', 'saveMessage'),
    loadMessage     : TextManager.getter('message', 'loadMessage'),
    file            : TextManager.getter('message', 'file'),
    partyName       : TextManager.getter('message', 'partyName'),
    emerge          : TextManager.getter('message', 'emerge'),
    preemptive      : TextManager.getter('message', 'preemptive'),
    surprise        : TextManager.getter('message', 'surprise'),
    escapeStart     : TextManager.getter('message', 'escapeStart'),
    escapeFailure   : TextManager.getter('message', 'escapeFailure'),
    victory         : TextManager.getter('message', 'victory'),
    defeat          : TextManager.getter('message', 'defeat'),
    obtainExp       : TextManager.getter('message', 'obtainExp'),
    obtainGold      : TextManager.getter('message', 'obtainGold'),
    obtainItem      : TextManager.getter('message', 'obtainItem'),
    levelUp         : TextManager.getter('message', 'levelUp'),
    obtainSkill     : TextManager.getter('message', 'obtainSkill'),
    useItem         : TextManager.getter('message', 'useItem'),
    criticalToEnemy : TextManager.getter('message', 'criticalToEnemy'),
    criticalToActor : TextManager.getter('message', 'criticalToActor'),
    actorDamage     : TextManager.getter('message', 'actorDamage'),
    actorRecovery   : TextManager.getter('message', 'actorRecovery'),
    actorGain       : TextManager.getter('message', 'actorGain'),
    actorLoss       : TextManager.getter('message', 'actorLoss'),
    actorDrain      : TextManager.getter('message', 'actorDrain'),
    actorNoDamage   : TextManager.getter('message', 'actorNoDamage'),
    actorNoHit      : TextManager.getter('message', 'actorNoHit'),
    enemyDamage     : TextManager.getter('message', 'enemyDamage'),
    enemyRecovery   : TextManager.getter('message', 'enemyRecovery'),
    enemyGain       : TextManager.getter('message', 'enemyGain'),
    enemyLoss       : TextManager.getter('message', 'enemyLoss'),
    enemyDrain      : TextManager.getter('message', 'enemyDrain'),
    enemyNoDamage   : TextManager.getter('message', 'enemyNoDamage'),
    enemyNoHit      : TextManager.getter('message', 'enemyNoHit'),
    evasion         : TextManager.getter('message', 'evasion'),
    magicEvasion    : TextManager.getter('message', 'magicEvasion'),
    magicReflection : TextManager.getter('message', 'magicReflection'),
    counterAttack   : TextManager.getter('message', 'counterAttack'),
    substitute      : TextManager.getter('message', 'substitute'),
    buffAdd         : TextManager.getter('message', 'buffAdd'),
    debuffAdd       : TextManager.getter('message', 'debuffAdd'),
    buffRemove      : TextManager.getter('message', 'buffRemove'),
    actionFailure   : TextManager.getter('message', 'actionFailure'),
});

//-----------------------------------------------------------------------------
// SceneManager
//
// The static class that manages scene transitions.

<span id='SceneManager-method-constructor'><span id='SceneManager'>/**
</span></span> * @class SceneManager
 * The static class that manages scene transitions.
 * @uses Graphics
 * @uses WebAudio
 * @uses Input
 * @uses TouchInput
 * @uses Utils
 * @uses PluginManager
 * @uses Window
 * @uses ImageManager
 * @uses Bitmap
 * @singleton
 * @static
 * @constructor should never be used
 */
function SceneManager() {
    throw new Error('This is a static class');
}

<span id='SceneManager-static-method-_getTimeInMsWithoutMobileSafari'>/**
</span> * @method _getTimeInMsWithoutMobileSafari
 * Gets the current time in ms without on iOS Safari.
 * @private
 * @static
 */
SceneManager._getTimeInMsWithoutMobileSafari = function() {
    return performance.now();
};

SceneManager._scene             = null;
SceneManager._nextScene         = null;
SceneManager._stack             = [];
SceneManager._stopped           = false;
SceneManager._sceneStarted      = false;
SceneManager._exiting           = false;
SceneManager._previousClass     = null;
SceneManager._backgroundBitmap  = null;
SceneManager._screenWidth       = 816;
SceneManager._screenHeight      = 624;
SceneManager._boxWidth          = 816;
SceneManager._boxHeight         = 624;
SceneManager._deltaTime = 1.0 / 60.0;
if (!Utils.isMobileSafari()) SceneManager._currentTime = SceneManager._getTimeInMsWithoutMobileSafari();
SceneManager._accumulator = 0.0;

SceneManager.run = function(sceneClass) {
    try {
        this.initialize();
        this.goto(sceneClass);
        this.requestUpdate();
    } catch (e) {
        this.catchException(e);
    }
};

SceneManager.initialize = function() {
    this.initGraphics();
    this.checkFileAccess();
    this.initAudio();
    this.initInput();
    this.initNwjs();
    this.checkPluginErrors();
    this.setupErrorHandlers();
};

SceneManager.initGraphics = function() {
    var type = this.preferableRendererType();
    Graphics.initialize(this._screenWidth, this._screenHeight, type);
    Graphics.boxWidth = this._boxWidth;
    Graphics.boxHeight = this._boxHeight;
    Graphics.setLoadingImage('img/system/Loading.png');
    if (Utils.isOptionValid('showfps')) {
        Graphics.showFps();
    }
    if (type === 'webgl') {
        this.checkWebGL();
    }
};

SceneManager.preferableRendererType = function() {
    if (Utils.isOptionValid('canvas')) {
        return 'canvas';
    } else if (Utils.isOptionValid('webgl')) {
        return 'webgl';
    } else {
        return 'auto';
    }
};

SceneManager.shouldUseCanvasRenderer = function() {
    return Utils.isMobileDevice();
};

SceneManager.checkWebGL = function() {
    if (!Graphics.hasWebGL()) {
        throw new Error('Your browser does not support WebGL.');
    }
};

SceneManager.checkFileAccess = function() {
    if (!Utils.canReadGameFiles()) {
        throw new Error('Your browser does not allow to read local files.');
    }
};

SceneManager.initAudio = function() {
    var noAudio = Utils.isOptionValid('noaudio');
    if (!WebAudio.initialize(noAudio) &amp;&amp; !noAudio) {
        throw new Error('Your browser does not support Web Audio API.');
    }
};

SceneManager.initInput = function() {
    Input.initialize();
    TouchInput.initialize();
};

SceneManager.initNwjs = function() {
    if (Utils.isNwjs()) {
        var gui = require('nw.gui');
        var win = gui.Window.get();
        if (process.platform === 'darwin' &amp;&amp; !win.menu) {
            var menubar = new gui.Menu({ type: 'menubar' });
            var option = { hideEdit: true, hideWindow: true };
            menubar.createMacBuiltin('Game', option);
            win.menu = menubar;
        }
    }
};

SceneManager.checkPluginErrors = function() {
    PluginManager.checkErrors();
};

SceneManager.setupErrorHandlers = function() {
    window.addEventListener('error', this.onError.bind(this));
    document.addEventListener('keydown', this.onKeyDown.bind(this));
};

SceneManager.requestUpdate = function() {
    if (!this._stopped) {
        requestAnimationFrame(this.update.bind(this));
    }
};

SceneManager.update = function() {
    try {
        this.tickStart();
        if (Utils.isMobileSafari()) {
            this.updateInputData();
        }
        this.updateManagers();
        this.updateMain();
        this.tickEnd();
    } catch (e) {
        this.catchException(e);
    }
};

SceneManager.terminate = function() {
    window.close();
};

SceneManager.onError = function(e) {
    console.error(e.message);
    console.error(e.filename, e.lineno);
    try {
        this.stop();
        Graphics.printError('Error', e.message);
        AudioManager.stopAll();
    } catch (e2) {
    }
};

SceneManager.onKeyDown = function(event) {
    if (!event.ctrlKey &amp;&amp; !event.altKey) {
        switch (event.keyCode) {
        case 116:   // F5
            if (Utils.isNwjs()) {
                location.reload();
            }
            break;
        case 119:   // F8
            if (Utils.isNwjs() &amp;&amp; Utils.isOptionValid('test')) {
                require('nw.gui').Window.get().showDevTools();
            }
            break;
        }
    }
};

SceneManager.catchException = function(e) {
    if (e instanceof Error) {
        Graphics.printError(e.name, e.message);
        console.error(e.stack);
    } else {
        Graphics.printError('UnknownError', e);
    }
    AudioManager.stopAll();
    this.stop();
};

SceneManager.tickStart = function() {
    Graphics.tickStart();
};

SceneManager.tickEnd = function() {
    Graphics.tickEnd();
};

SceneManager.updateInputData = function() {
    Input.update();
    TouchInput.update();
};

SceneManager.updateMain = function() {
    if (Utils.isMobileSafari()) {
        this.changeScene();
        this.updateScene();
    } else {
        var newTime = this._getTimeInMsWithoutMobileSafari();
        var fTime = (newTime - this._currentTime) / 1000;
        if (fTime &gt; 0.25) fTime = 0.25;
        this._currentTime = newTime;
        this._accumulator += fTime;
        while (this._accumulator &gt;= this._deltaTime) {
            this.updateInputData();
            this.changeScene();
            this.updateScene();
            this._accumulator -= this._deltaTime;
        }
    }
    this.renderScene();
    this.requestUpdate();
};

SceneManager.updateManagers = function() {
    ImageManager.update();
};

SceneManager.changeScene = function() {
    if (this.isSceneChanging() &amp;&amp; !this.isCurrentSceneBusy()) {
        if (this._scene) {
            this._scene.terminate();
            this._scene.detachReservation();
            this._previousClass = this._scene.constructor;
        }
        this._scene = this._nextScene;
        if (this._scene) {
            this._scene.attachReservation();
            this._scene.create();
            this._nextScene = null;
            this._sceneStarted = false;
            this.onSceneCreate();
        }
        if (this._exiting) {
            this.terminate();
        }
    }
};

SceneManager.updateScene = function() {
    if (this._scene) {
        if (!this._sceneStarted &amp;&amp; this._scene.isReady()) {
            this._scene.start();
            this._sceneStarted = true;
            this.onSceneStart();
        }
        if (this.isCurrentSceneStarted()) {
            this._scene.update();
        }
    }
};

SceneManager.renderScene = function() {
    if (this.isCurrentSceneStarted()) {
        Graphics.render(this._scene);
    } else if (this._scene) {
        this.onSceneLoading();
    }
};

SceneManager.onSceneCreate = function() {
    Graphics.startLoading();
};

SceneManager.onSceneStart = function() {
    Graphics.endLoading();
};

SceneManager.onSceneLoading = function() {
    Graphics.updateLoading();
};

SceneManager.isSceneChanging = function() {
    return this._exiting || !!this._nextScene;
};

SceneManager.isCurrentSceneBusy = function() {
    return this._scene &amp;&amp; this._scene.isBusy();
};

SceneManager.isCurrentSceneStarted = function() {
    return this._scene &amp;&amp; this._sceneStarted;
};

SceneManager.isNextScene = function(sceneClass) {
    return this._nextScene &amp;&amp; this._nextScene.constructor === sceneClass;
};

SceneManager.isPreviousScene = function(sceneClass) {
    return this._previousClass === sceneClass;
};

SceneManager.goto = function(sceneClass) {
    if (sceneClass) {
        this._nextScene = new sceneClass();
    }
    if (this._scene) {
        this._scene.stop();
    }
};

SceneManager.push = function(sceneClass) {
    this._stack.push(this._scene.constructor);
    this.goto(sceneClass);
};

SceneManager.pop = function() {
    if (this._stack.length &gt; 0) {
        this.goto(this._stack.pop());
    } else {
        this.exit();
    }
};

SceneManager.exit = function() {
    this.goto(null);
    this._exiting = true;
};

SceneManager.clearStack = function() {
    this._stack = [];
};

SceneManager.stop = function() {
    this._stopped = true;
};

SceneManager.prepareNextScene = function() {
    this._nextScene.prepare.apply(this._nextScene, arguments);
};

SceneManager.snap = function() {
    return Bitmap.snap(this._scene);
};

SceneManager.snapForBackground = function() {
    this._backgroundBitmap = this.snap();
    this._backgroundBitmap.blur();
};

SceneManager.backgroundBitmap = function() {
    return this._backgroundBitmap;
};

SceneManager.resume = function() {
    this._stopped = false;
    this.requestUpdate();
    if (!Utils.isMobileSafari()) {
        this._currentTime = this._getTimeInMsWithoutMobileSafari();
        this._accumulator = 0;
    }
};

//-----------------------------------------------------------------------------
// BattleManager
//
// The static class that manages battle progress.

function BattleManager() {
    throw new Error('This is a static class');
}

BattleManager.setup = function(troopId, canEscape, canLose) {
    this.initMembers();
    this._canEscape = canEscape;
    this._canLose = canLose;
    $gameTroop.setup(troopId);
    $gameScreen.onBattleStart();
    this.makeEscapeRatio();
};

BattleManager.initMembers = function() {
    this._phase = 'init';
    this._canEscape = false;
    this._canLose = false;
    this._battleTest = false;
    this._eventCallback = null;
    this._preemptive = false;
    this._surprise = false;
    this._actorIndex = -1;
    this._actionForcedBattler = null;
    this._mapBgm = null;
    this._mapBgs = null;
    this._actionBattlers = [];
    this._subject = null;
    this._action = null;
    this._targets = [];
    this._logWindow = null;
    this._statusWindow = null;
    this._spriteset = null;
    this._escapeRatio = 0;
    this._escaped = false;
    this._rewards = {};
    this._turnForced = false;
};

BattleManager.isBattleTest = function() {
    return this._battleTest;
};

BattleManager.setBattleTest = function(battleTest) {
    this._battleTest = battleTest;
};

BattleManager.setEventCallback = function(callback) {
    this._eventCallback = callback;
};

BattleManager.setLogWindow = function(logWindow) {
    this._logWindow = logWindow;
};

BattleManager.setStatusWindow = function(statusWindow) {
    this._statusWindow = statusWindow;
};

BattleManager.setSpriteset = function(spriteset) {
    this._spriteset = spriteset;
};

BattleManager.onEncounter = function() {
    this._preemptive = (Math.random() &lt; this.ratePreemptive());
    this._surprise = (Math.random() &lt; this.rateSurprise() &amp;&amp; !this._preemptive);
};

BattleManager.ratePreemptive = function() {
    return $gameParty.ratePreemptive($gameTroop.agility());
};

BattleManager.rateSurprise = function() {
    return $gameParty.rateSurprise($gameTroop.agility());
};

BattleManager.saveBgmAndBgs = function() {
    this._mapBgm = AudioManager.saveBgm();
    this._mapBgs = AudioManager.saveBgs();
};

BattleManager.playBattleBgm = function() {
    AudioManager.playBgm($gameSystem.battleBgm());
    AudioManager.stopBgs();
};

BattleManager.playVictoryMe = function() {
    AudioManager.playMe($gameSystem.victoryMe());
};

BattleManager.playDefeatMe = function() {
    AudioManager.playMe($gameSystem.defeatMe());
};

BattleManager.replayBgmAndBgs = function() {
    if (this._mapBgm) {
        AudioManager.replayBgm(this._mapBgm);
    } else {
        AudioManager.stopBgm();
    }
    if (this._mapBgs) {
        AudioManager.replayBgs(this._mapBgs);
    }
};

BattleManager.makeEscapeRatio = function() {
    this._escapeRatio = 0.5 * $gameParty.agility() / $gameTroop.agility();
};

BattleManager.update = function() {
    if (!this.isBusy() &amp;&amp; !this.updateEvent()) {
        switch (this._phase) {
        case 'start':
            this.startInput();
            break;
        case 'turn':
            this.updateTurn();
            break;
        case 'action':
            this.updateAction();
            break;
        case 'turnEnd':
            this.updateTurnEnd();
            break;
        case 'battleEnd':
            this.updateBattleEnd();
            break;
        }
    }
};

BattleManager.updateEvent = function() {
    switch (this._phase) {
        case 'start':
        case 'turn':
        case 'turnEnd':
            if (this.isActionForced()) {
                this.processForcedAction();
                return true;
            } else {
                return this.updateEventMain();
            }
    }
    return this.checkAbort2();
};

BattleManager.updateEventMain = function() {
    $gameTroop.updateInterpreter();
    $gameParty.requestMotionRefresh();
    if ($gameTroop.isEventRunning() || this.checkBattleEnd()) {
        return true;
    }
    $gameTroop.setupBattleEvent();
    if ($gameTroop.isEventRunning() || SceneManager.isSceneChanging()) {
        return true;
    }
    return false;
};

BattleManager.isBusy = function() {
    return ($gameMessage.isBusy() || this._spriteset.isBusy() ||
            this._logWindow.isBusy());
};

BattleManager.isInputting = function() {
    return this._phase === 'input';
};

BattleManager.isInTurn = function() {
    return this._phase === 'turn';
};

BattleManager.isTurnEnd = function() {
    return this._phase === 'turnEnd';
};

BattleManager.isAborting = function() {
    return this._phase === 'aborting';
};

BattleManager.isBattleEnd = function() {
    return this._phase === 'battleEnd';
};

BattleManager.canEscape = function() {
    return this._canEscape;
};

BattleManager.canLose = function() {
    return this._canLose;
};

BattleManager.isEscaped = function() {
    return this._escaped;
};

BattleManager.actor = function() {
    return this._actorIndex &gt;= 0 ? $gameParty.members()[this._actorIndex] : null;
};

BattleManager.clearActor = function() {
    this.changeActor(-1, '');
};

BattleManager.changeActor = function(newActorIndex, lastActorActionState) {
    var lastActor = this.actor();
    this._actorIndex = newActorIndex;
    var newActor = this.actor();
    if (lastActor) {
        lastActor.setActionState(lastActorActionState);
    }
    if (newActor) {
        newActor.setActionState('inputting');
    }
};

BattleManager.startBattle = function() {
    this._phase = 'start';
    $gameSystem.onBattleStart();
    $gameParty.onBattleStart();
    $gameTroop.onBattleStart();
    this.displayStartMessages();
};

BattleManager.displayStartMessages = function() {
    $gameTroop.enemyNames().forEach(function(name) {
        $gameMessage.add(TextManager.emerge.format(name));
    });
    if (this._preemptive) {
        $gameMessage.add(TextManager.preemptive.format($gameParty.name()));
    } else if (this._surprise) {
        $gameMessage.add(TextManager.surprise.format($gameParty.name()));
    }
};

BattleManager.startInput = function() {
    this._phase = 'input';
    $gameParty.makeActions();
    $gameTroop.makeActions();
    this.clearActor();
    if (this._surprise || !$gameParty.canInput()) {
        this.startTurn();
    }
};

BattleManager.inputtingAction = function() {
    return this.actor() ? this.actor().inputtingAction() : null;
};

BattleManager.selectNextCommand = function() {
    do {
        if (!this.actor() || !this.actor().selectNextCommand()) {
            this.changeActor(this._actorIndex + 1, 'waiting');
            if (this._actorIndex &gt;= $gameParty.size()) {
                this.startTurn();
                break;
            }
        }
    } while (!this.actor().canInput());
};

BattleManager.selectPreviousCommand = function() {
    do {
        if (!this.actor() || !this.actor().selectPreviousCommand()) {
            this.changeActor(this._actorIndex - 1, 'undecided');
            if (this._actorIndex &lt; 0) {
                return;
            }
        }
    } while (!this.actor().canInput());
};

BattleManager.refreshStatus = function() {
    this._statusWindow.refresh();
};

BattleManager.startTurn = function() {
    this._phase = 'turn';
    this.clearActor();
    $gameTroop.increaseTurn();
    this.makeActionOrders();
    $gameParty.requestMotionRefresh();
    this._logWindow.startTurn();
};

BattleManager.updateTurn = function() {
    $gameParty.requestMotionRefresh();
    if (!this._subject) {
        this._subject = this.getNextSubject();
    }
    if (this._subject) {
        this.processTurn();
    } else {
        this.endTurn();
    }
};

BattleManager.processTurn = function() {
    var subject = this._subject;
    var action = subject.currentAction();
    if (action) {
        action.prepare();
        if (action.isValid()) {
            this.startAction();
        }
        subject.removeCurrentAction();
    } else {
        subject.onAllActionsEnd();
        this.refreshStatus();
        this._logWindow.displayAutoAffectedStatus(subject);
        this._logWindow.displayCurrentState(subject);
        this._logWindow.displayRegeneration(subject);
        this._subject = this.getNextSubject();
    }
};

BattleManager.endTurn = function() {
    this._phase = 'turnEnd';
    this._preemptive = false;
    this._surprise = false;
    this.allBattleMembers().forEach(function(battler) {
        battler.onTurnEnd();
        this.refreshStatus();
        this._logWindow.displayAutoAffectedStatus(battler);
        this._logWindow.displayRegeneration(battler);
    }, this);
    if (this.isForcedTurn()) {
        this._turnForced = false;
    }
};

BattleManager.isForcedTurn = function () {
    return this._turnForced;
};

BattleManager.updateTurnEnd = function() {
    this.startInput();
};

BattleManager.getNextSubject = function() {
    for (;;) {
        var battler = this._actionBattlers.shift();
        if (!battler) {
            return null;
        }
        if (battler.isBattleMember() &amp;&amp; battler.isAlive()) {
            return battler;
        }
    }
};

BattleManager.allBattleMembers = function() {
    return $gameParty.members().concat($gameTroop.members());
};

BattleManager.makeActionOrders = function() {
    var battlers = [];
    if (!this._surprise) {
        battlers = battlers.concat($gameParty.members());
    }
    if (!this._preemptive) {
        battlers = battlers.concat($gameTroop.members());
    }
    battlers.forEach(function(battler) {
        battler.makeSpeed();
    });
    battlers.sort(function(a, b) {
        return b.speed() - a.speed();
    });
    this._actionBattlers = battlers;
};

BattleManager.startAction = function() {
    var subject = this._subject;
    var action = subject.currentAction();
    var targets = action.makeTargets();
    this._phase = 'action';
    this._action = action;
    this._targets = targets;
    subject.useItem(action.item());
    this._action.applyGlobal();
    this.refreshStatus();
    this._logWindow.startAction(subject, action, targets);
};

BattleManager.updateAction = function() {
    var target = this._targets.shift();
    if (target) {
        this.invokeAction(this._subject, target);
    } else {
        this.endAction();
    }
};

BattleManager.endAction = function() {
    this._logWindow.endAction(this._subject);
    this._phase = 'turn';
};

BattleManager.invokeAction = function(subject, target) {
    this._logWindow.push('pushBaseLine');
    if (Math.random() &lt; this._action.itemCnt(target)) {
        this.invokeCounterAttack(subject, target);
    } else if (Math.random() &lt; this._action.itemMrf(target)) {
        this.invokeMagicReflection(subject, target);
    } else {
        this.invokeNormalAction(subject, target);
    }
    subject.setLastTarget(target);
    this._logWindow.push('popBaseLine');
    this.refreshStatus();
};

BattleManager.invokeNormalAction = function(subject, target) {
    var realTarget = this.applySubstitute(target);
    this._action.apply(realTarget);
    this._logWindow.displayActionResults(subject, realTarget);
};

BattleManager.invokeCounterAttack = function(subject, target) {
    var action = new Game_Action(target);
    action.setAttack();
    action.apply(subject);
    this._logWindow.displayCounter(target);
    this._logWindow.displayActionResults(target, subject);
};

BattleManager.invokeMagicReflection = function(subject, target) {
	this._action._reflectionTarget = target;
    this._logWindow.displayReflection(target);
    this._action.apply(subject);
    this._logWindow.displayActionResults(target, subject);
};

BattleManager.applySubstitute = function(target) {
    if (this.checkSubstitute(target)) {
        var substitute = target.friendsUnit().substituteBattler();
        if (substitute &amp;&amp; target !== substitute) {
            this._logWindow.displaySubstitute(substitute, target);
            return substitute;
        }
    }
    return target;
};

BattleManager.checkSubstitute = function(target) {
    return target.isDying() &amp;&amp; !this._action.isCertainHit();
};

BattleManager.isActionForced = function() {
    return !!this._actionForcedBattler;
};

BattleManager.forceAction = function(battler) {
    this._actionForcedBattler = battler;
    var index = this._actionBattlers.indexOf(battler);
    if (index &gt;= 0) {
        this._actionBattlers.splice(index, 1);
    }
};

BattleManager.processForcedAction = function() {
    if (this._actionForcedBattler) {
        this._turnForced = true;
        this._subject = this._actionForcedBattler;
        this._actionForcedBattler = null;
        this.startAction();
        this._subject.removeCurrentAction();
    }
};

BattleManager.abort = function() {
    this._phase = 'aborting';
};

BattleManager.checkBattleEnd = function() {
    if (this._phase) {
        if (this.checkAbort()) {
            return true;
        } else if ($gameParty.isAllDead()) {
            this.processDefeat();
            return true;
        } else if ($gameTroop.isAllDead()) {
            this.processVictory();
            return true;
        }
    }
    return false;
};

BattleManager.checkAbort = function() {
    if ($gameParty.isEmpty() || this.isAborting()) {
        this.processAbort();
        return true;
    }
    return false;
};

BattleManager.checkAbort2 = function() {
    if ($gameParty.isEmpty() || this.isAborting()) {
        SoundManager.playEscape();
        this._escaped = true;
        this.processAbort();
    }
    return false;
};

BattleManager.processVictory = function() {
    $gameParty.removeBattleStates();
    $gameParty.performVictory();
    this.playVictoryMe();
    this.replayBgmAndBgs();
    this.makeRewards();
    this.displayVictoryMessage();
    this.displayRewards();
    this.gainRewards();
    this.endBattle(0);
};

BattleManager.processEscape = function() {
    $gameParty.performEscape();
    SoundManager.playEscape();
    var success = this._preemptive ? true : (Math.random() &lt; this._escapeRatio);
    if (success) {
        this.displayEscapeSuccessMessage();
        this._escaped = true;
        this.processAbort();
    } else {
        this.displayEscapeFailureMessage();
        this._escapeRatio += 0.1;
        $gameParty.clearActions();
        this.startTurn();
    }
    return success;
};

BattleManager.processAbort = function() {
    $gameParty.removeBattleStates();
    this.replayBgmAndBgs();
    this.endBattle(1);
};

BattleManager.processDefeat = function() {
    this.displayDefeatMessage();
    this.playDefeatMe();
    if (this._canLose) {
        this.replayBgmAndBgs();
    } else {
        AudioManager.stopBgm();
    }
    this.endBattle(2);
};

BattleManager.endBattle = function(result) {
    this._phase = 'battleEnd';
    if (this._eventCallback) {
        this._eventCallback(result);
    }
    if (result === 0) {
        $gameSystem.onBattleWin();
    } else if (this._escaped) {
        $gameSystem.onBattleEscape();
    }
};

BattleManager.updateBattleEnd = function() {
    if (this.isBattleTest()) {
        AudioManager.stopBgm();
        SceneManager.exit();
    } else if (!this._escaped &amp;&amp; $gameParty.isAllDead()) {
        if (this._canLose) {
            $gameParty.reviveBattleMembers();
            SceneManager.pop();
        } else {
            SceneManager.goto(Scene_Gameover);
        }
    } else {
        SceneManager.pop();
    }
    this._phase = null;
};

BattleManager.makeRewards = function() {
    this._rewards = {};
    this._rewards.gold = $gameTroop.goldTotal();
    this._rewards.exp = $gameTroop.expTotal();
    this._rewards.items = $gameTroop.makeDropItems();
};

BattleManager.displayVictoryMessage = function() {
    $gameMessage.add(TextManager.victory.format($gameParty.name()));
};

BattleManager.displayDefeatMessage = function() {
    $gameMessage.add(TextManager.defeat.format($gameParty.name()));
};

BattleManager.displayEscapeSuccessMessage = function() {
    $gameMessage.add(TextManager.escapeStart.format($gameParty.name()));
};

BattleManager.displayEscapeFailureMessage = function() {
    $gameMessage.add(TextManager.escapeStart.format($gameParty.name()));
    $gameMessage.add('\\.' + TextManager.escapeFailure);
};

BattleManager.displayRewards = function() {
    this.displayExp();
    this.displayGold();
    this.displayDropItems();
};

BattleManager.displayExp = function() {
    var exp = this._rewards.exp;
    if (exp &gt; 0) {
        var text = TextManager.obtainExp.format(exp, TextManager.exp);
        $gameMessage.add('\\.' + text);
    }
};

BattleManager.displayGold = function() {
    var gold = this._rewards.gold;
    if (gold &gt; 0) {
        $gameMessage.add('\\.' + TextManager.obtainGold.format(gold));
    }
};

BattleManager.displayDropItems = function() {
    var items = this._rewards.items;
    if (items.length &gt; 0) {
        $gameMessage.newPage();
        items.forEach(function(item) {
            $gameMessage.add(TextManager.obtainItem.format(item.name));
        });
    }
};

BattleManager.gainRewards = function() {
    this.gainExp();
    this.gainGold();
    this.gainDropItems();
};

BattleManager.gainExp = function() {
    var exp = this._rewards.exp;
    $gameParty.allMembers().forEach(function(actor) {
        actor.gainExp(exp);
    });
};

BattleManager.gainGold = function() {
    $gameParty.gainGold(this._rewards.gold);
};

BattleManager.gainDropItems = function() {
    var items = this._rewards.items;
    items.forEach(function(item) {
        $gameParty.gainItem(item, 1);
    });
};

//-----------------------------------------------------------------------------
// PluginManager
//
// The static class that manages the plugins.

function PluginManager() {
    throw new Error('This is a static class');
}

PluginManager._path         = 'js/plugins/';
PluginManager._scripts      = [];
PluginManager._errorUrls    = [];
PluginManager._parameters   = {};

PluginManager.setup = function(plugins) {
    plugins.forEach(function(plugin) {
        if (plugin.status &amp;&amp; !this._scripts.contains(plugin.name)) {
            this.setParameters(plugin.name, plugin.parameters);
            this.loadScript(plugin.name + '.js');
            this._scripts.push(plugin.name);
        }
    }, this);
};

PluginManager.checkErrors = function() {
    var url = this._errorUrls.shift();
    if (url) {
        throw new Error('Failed to load: ' + url);
    }
};

PluginManager.parameters = function(name) {
    return this._parameters[name.toLowerCase()] || {};
};

PluginManager.setParameters = function(name, parameters) {
    this._parameters[name.toLowerCase()] = parameters;
};

PluginManager.loadScript = function(name) {
    var url = this._path + name;
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.async = false;
    script.onerror = this.onError.bind(this);
    script._url = url;
    document.body.appendChild(script);
};

PluginManager.onError = function(e) {
    this._errorUrls.push(e.target._url);
};
</pre>
</body>
</html>
